#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:01:48 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  1.5                  1
[INPUT] 0    0    [1    /1   ]  1                    1
[INPUT] 0    0    [1    /1   ]  0.5                  1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [1.5, 1.0]], [0, [1.0, 1.0]], [0, [0.5, 1.0]]]}
ecp = {}
CPU time:         1.06
Set gradient conv threshold to 3.16228e-05
cond(S) = 534.7328219544956
E1 = -3.6165014208895343  E_coul = 0.9941505692055911
init E= -2.62235085168394
    CPU time for initialize scf      0.11 sec, wall time      0.11 sec
  HOMO = -0.828324530545272  LUMO = 1.48813617720673
  mo_energy =
[-0.82832453  1.48813618  4.77933295]
E1 = -3.629467726441384  E_coul = 0.9773529101589499
cycle= 1 E= -2.65211481628243  delta_E= -0.0298  |g|= 0.0344  |ddm|= 2.26
    CPU time for cycle= 1      0.25 sec, wall time      0.25 sec
  HOMO = -0.837444817598505  LUMO = 1.49554497596787
  mo_energy =
[-0.83744482  1.49554498  4.77435195]
E1 = -3.6255231804733  E_coul = 0.9732692913148208
cycle= 2 E= -2.65225388915848  delta_E= -0.000139  |g|= 0.00306  |ddm|= 0.197
    CPU time for cycle= 2      0.07 sec, wall time      0.07 sec
  HOMO = -0.839691458564032  LUMO = 1.49473990869774
  mo_energy =
[-0.83969146  1.49473991  4.77143048]
E1 = -3.6251315109365474  E_coul = 0.9728765145630002
cycle= 3 E= -2.65225499637355  delta_E= -1.11e-06  |g|= 4.32e-06  |ddm|= 0.0194
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.839688939712789  LUMO = 1.49474023900453
  mo_energy =
[-0.83968894  1.49474024  4.77143129]
E1 = -3.625131754825602  E_coul = 0.9728767584497712
cycle= 4 E= -2.65225499637583  delta_E= -2.28e-12  |g|= 5.41e-08  |ddm|= 5.88e-05
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.625131754825602  E_coul = 0.9728767584497712
  HOMO = -0.839689118963031  LUMO = 1.49474029891724
  mo_energy =
[-0.83968912  1.4947403   4.7714314 ]
E1 = -3.625131766594653  E_coul = 0.9728767702188204
Extra cycle  E= -2.65225499637583  delta_E= -1.78e-15  |g|= 6.61e-09  |ddm|= 4.92e-07
    CPU time for scf_cycle      0.45 sec, wall time      0.45 sec
exp = [1.5 1.  0.5]
E = -2.6522549963758326
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:01:48 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  1.5                  1
[INPUT] 0    0    [1    /1   ]  1                    1
[INPUT] 0    0    [1    /1   ]  0.5                  1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [1.5, 1.0]], [0, [1.0, 1.0]], [0, [0.5, 1.0]]]}
ecp = {}
CPU time:         1.61
Set gradient conv threshold to 3.16228e-05
cond(S) = 534.7328219544956
E1 = -3.6165014208895343  E_coul = 0.9941505692055911
init E= -2.62235085168394
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.828324530545272  LUMO = 1.48813617720673
  mo_energy =
[-0.82832453  1.48813618  4.77933295]
E1 = -3.629467726441384  E_coul = 0.9773529101589499
cycle= 1 E= -2.65211481628243  delta_E= -0.0298  |g|= 0.0344  |ddm|= 2.26
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.837444817598505  LUMO = 1.49554497596787
  mo_energy =
[-0.83744482  1.49554498  4.77435195]
E1 = -3.6255231804733  E_coul = 0.9732692913148208
cycle= 2 E= -2.65225388915848  delta_E= -0.000139  |g|= 0.00306  |ddm|= 0.197
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.839691458564032  LUMO = 1.49473990869774
  mo_energy =
[-0.83969146  1.49473991  4.77143048]
E1 = -3.6251315109365474  E_coul = 0.9728765145630002
cycle= 3 E= -2.65225499637355  delta_E= -1.11e-06  |g|= 4.32e-06  |ddm|= 0.0194
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.839688939712789  LUMO = 1.49474023900453
  mo_energy =
[-0.83968894  1.49474024  4.77143129]
E1 = -3.625131754825602  E_coul = 0.9728767584497712
cycle= 4 E= -2.65225499637583  delta_E= -2.28e-12  |g|= 5.41e-08  |ddm|= 5.88e-05
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.625131754825602  E_coul = 0.9728767584497712
  HOMO = -0.839689118963031  LUMO = 1.49474029891724
  mo_energy =
[-0.83968912  1.4947403   4.7714314 ]
E1 = -3.625131766594653  E_coul = 0.9728767702188204
Extra cycle  E= -2.65225499637583  delta_E= -1.78e-15  |g|= 6.61e-09  |ddm|= 4.92e-07
    CPU time for scf_cycle      0.06 sec, wall time      0.06 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 534.7328219544956
E1 = -3.625131766594653  E_coul = 0.9728767702188204
init E= -2.65225499637583
    CPU time for initialize scf      0.22 sec, wall time      0.22 sec
  HOMO = -0.839689113078507  LUMO = 1.49474030188044
  mo_energy =
[-0.83968911  1.4947403   4.77143141]
E1 = -3.625131767923533  E_coul = 0.9728767715476988
cycle= 1 E= -2.65225499637583  delta_E= -1.33e-15  |g|= 8.56e-10  |ddm|= 7.25e-08
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -3.625131767923533  E_coul = 0.9728767715476988
  HOMO = -0.839689112414068  LUMO = 1.49474030222931
  mo_energy =
[-0.83968911  1.4947403   4.77143141]
E1 = -3.6251317680786066  E_coul = 0.9728767717027748
Extra cycle  E= -2.65225499637583  delta_E= 2.22e-15  |g|= 1.13e-10  |ddm|= 1.02e-08
    CPU time for scf_cycle      0.77 sec, wall time      0.77 sec
exp = [1.5 1.  0.5]
grad_E = [-0.07174848 -0.04232189 -0.0096549 ]
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:01:52 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  1.57174848072        1
[INPUT] 0    0    [1    /1   ]  1.04232188718        1
[INPUT] 0    0    [1    /1   ]  0.509654901053       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [1.5717484807159159, 1.0]], [0, [1.0423218871767657, 1.0]], [0, [0.509654901052853, 1.0]]]}
ecp = {}
CPU time:         5.74
Set gradient conv threshold to 3.16228e-05
cond(S) = 491.9063391213217
E1 = -3.6259446450859665  E_coul = 0.9970299748473743
init E= -2.62891467023859
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.830240548065818  LUMO = 1.54258269240557
  mo_energy =
[-0.83024055  1.54258269  4.97529457]
E1 = -3.6424802743563616  E_coul = 0.983705675162868
cycle= 1 E= -2.65877459919349  delta_E= -0.0299  |g|= 0.0349  |ddm|=  2.2
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.837595259317153  LUMO = 1.55086597584018
  mo_energy =
[-0.83759526  1.55086598  4.97234684]
E1 = -3.6389413239697355  E_coul = 0.9800344962780266
cycle= 2 E= -2.65890682769171  delta_E= -0.000132  |g|= 0.0031  |ddm|= 0.193
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.839608193276476  LUMO = 1.55015091862158
  mo_energy =
[-0.83960819  1.55015092  4.96968021]
E1 = -3.638609825528994  E_coul = 0.9797019745598605
cycle= 3 E= -2.65890785096913  delta_E= -1.02e-06  |g|= 2.02e-05  |ddm|= 0.0196
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.839602007380711  LUMO = 1.55015464284499
  mo_energy =
[-0.83960201  1.55015464  4.9696878 ]
E1 = -3.6386113384193184  E_coul = 0.979703487398733
cycle= 4 E= -2.65890785102059  delta_E= -5.15e-11  |g|= 6.24e-08  |ddm|= 0.000249
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.6386113384193184  E_coul = 0.979703487398733
  HOMO = -0.839602181810926  LUMO = 1.55015468600078
  mo_energy =
[-0.83960218  1.55015469  4.9696879 ]
E1 = -3.6386113520087253  E_coul = 0.9797035009881384
Extra cycle  E= -2.65890785102059  delta_E= -1.78e-15  |g|= 7.3e-09  |ddm|= 4.61e-07
    CPU time for scf_cycle      0.06 sec, wall time      0.06 sec
exp = [1.57174848 1.04232189 0.5096549 ]
E = -2.658907851020587
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:01:52 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  1.57174848072        1
[INPUT] 0    0    [1    /1   ]  1.04232188718        1
[INPUT] 0    0    [1    /1   ]  0.509654901053       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [1.5717484807159159, 1.0]], [0, [1.0423218871767657, 1.0]], [0, [0.509654901052853, 1.0]]]}
ecp = {}
CPU time:         5.84
Set gradient conv threshold to 3.16228e-05
cond(S) = 491.9063391213217
E1 = -3.6259446450859665  E_coul = 0.9970299748473743
init E= -2.62891467023859
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.830240548065818  LUMO = 1.54258269240557
  mo_energy =
[-0.83024055  1.54258269  4.97529457]
E1 = -3.6424802743563616  E_coul = 0.983705675162868
cycle= 1 E= -2.65877459919349  delta_E= -0.0299  |g|= 0.0349  |ddm|=  2.2
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.837595259317153  LUMO = 1.55086597584018
  mo_energy =
[-0.83759526  1.55086598  4.97234684]
E1 = -3.6389413239697355  E_coul = 0.9800344962780266
cycle= 2 E= -2.65890682769171  delta_E= -0.000132  |g|= 0.0031  |ddm|= 0.193
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.839608193276476  LUMO = 1.55015091862158
  mo_energy =
[-0.83960819  1.55015092  4.96968021]
E1 = -3.638609825528994  E_coul = 0.9797019745598605
cycle= 3 E= -2.65890785096913  delta_E= -1.02e-06  |g|= 2.02e-05  |ddm|= 0.0196
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.839602007380711  LUMO = 1.55015464284499
  mo_energy =
[-0.83960201  1.55015464  4.9696878 ]
E1 = -3.6386113384193184  E_coul = 0.979703487398733
cycle= 4 E= -2.65890785102059  delta_E= -5.15e-11  |g|= 6.24e-08  |ddm|= 0.000249
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.6386113384193184  E_coul = 0.979703487398733
  HOMO = -0.839602181810926  LUMO = 1.55015468600078
  mo_energy =
[-0.83960218  1.55015469  4.9696879 ]
E1 = -3.6386113520087253  E_coul = 0.9797035009881384
Extra cycle  E= -2.65890785102059  delta_E= -1.78e-15  |g|= 7.3e-09  |ddm|= 4.61e-07
    CPU time for scf_cycle      0.06 sec, wall time      0.06 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 491.9063391213217
E1 = -3.6386113520087253  E_coul = 0.9797035009881384
init E= -2.65890785102059
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  HOMO = -0.839602175016225  LUMO = 1.55015468946871
  mo_energy =
[-0.83960218  1.55015469  4.96968791]
E1 = -3.638611353501196  E_coul = 0.9797035024806096
cycle= 1 E= -2.65890785102059  delta_E= 4.44e-16  |g|= 9.19e-10  |ddm|= 6.81e-08
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -3.638611353501196  E_coul = 0.9797035024806096
  HOMO = -0.839602174269988  LUMO = 1.55015468986612
  mo_energy =
[-0.83960217  1.55015469  4.96968792]
E1 = -3.6386113536708904  E_coul = 0.9797035026503054
Extra cycle  E= -2.65890785102058  delta_E= 1.78e-15  |g|= 1.19e-10  |ddm|= 9.56e-09
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
exp = [1.57174848 1.04232189 0.5096549 ]
grad_E = [-0.06603582 -0.0374748   0.00398565]
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:01:54 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  1.93911836803        1
[INPUT] 0    0    [1    /1   ]  1.2516334176         1
[INPUT] 0    0    [1    /1   ]  0.494731283827       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [1.9391183680331907, 1.0]], [0, [1.2516334175969535, 1.0]], [0, [0.4947312838268484, 1.0]]]}
ecp = {}
CPU time:         7.70
Set gradient conv threshold to 3.16228e-05
cond(S) = 273.9518883098533
E1 = -3.664678842450779  E_coul = 1.0054957330082286
init E= -2.65918310944255
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.839993102877531  LUMO = 1.68026757852018
  mo_energy =
[-0.8399931   1.68026758  5.75869701]
E1 = -3.6860049856385944  E_coul = 0.9995441081242961
cycle= 1 E= -2.6864608775143  delta_E= -0.0273  |g|= 0.033  |ddm|= 1.08
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.843503749863154  LUMO = 1.6895313398954
  mo_energy =
[-0.84350375  1.68953134  5.75871   ]
E1 = -3.6834332720442946  E_coul = 0.996874164286833
cycle= 2 E= -2.68655910775746  delta_E= -9.82e-05  |g|= 0.00281  |ddm|= 0.0911
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.84495349629718  LUMO = 1.68897632022709
  mo_energy =
[-0.8449535   1.68897632  5.75651797]
E1 = -3.6832326034620677  E_coul = 0.9966728092065142
cycle= 3 E= -2.68655979425555  delta_E= -6.86e-07  |g|= 4.12e-05  |ddm|= 0.00916
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.84494176462753  LUMO = 1.68898560640876
  mo_energy =
[-0.84494176  1.68898561  5.75653765]
E1 = -3.683235849873935  E_coul = 0.9966760554267595
cycle= 4 E= -2.68655979444718  delta_E= -1.92e-10  |g|= 5.08e-08  |ddm|= 0.000222
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.683235849873935  E_coul = 0.9966760554267595
  HOMO = -0.844941869510208  LUMO = 1.68898561600657
  mo_energy =
[-0.84494187  1.68898562  5.75653771]
E1 = -3.683235860734141  E_coul = 0.9966760662869663
Extra cycle  E= -2.68655979444717  delta_E= 8.88e-16  |g|= 5.27e-09  |ddm|= 1.47e-07
    CPU time for scf_cycle      0.06 sec, wall time      0.06 sec
exp = [1.93911837 1.25163342 0.49473128]
E = -2.6865597944471746
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:01:54 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  1.93911836803        1
[INPUT] 0    0    [1    /1   ]  1.2516334176         1
[INPUT] 0    0    [1    /1   ]  0.494731283827       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [1.9391183680331907, 1.0]], [0, [1.2516334175969535, 1.0]], [0, [0.4947312838268484, 1.0]]]}
ecp = {}
CPU time:         7.82
Set gradient conv threshold to 3.16228e-05
cond(S) = 273.9518883098533
E1 = -3.664678842450779  E_coul = 1.0054957330082286
init E= -2.65918310944255
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.839993102877531  LUMO = 1.68026757852018
  mo_energy =
[-0.8399931   1.68026758  5.75869701]
E1 = -3.6860049856385944  E_coul = 0.9995441081242961
cycle= 1 E= -2.6864608775143  delta_E= -0.0273  |g|= 0.033  |ddm|= 1.08
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.843503749863154  LUMO = 1.6895313398954
  mo_energy =
[-0.84350375  1.68953134  5.75871   ]
E1 = -3.6834332720442946  E_coul = 0.996874164286833
cycle= 2 E= -2.68655910775746  delta_E= -9.82e-05  |g|= 0.00281  |ddm|= 0.0911
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.84495349629718  LUMO = 1.68897632022709
  mo_energy =
[-0.8449535   1.68897632  5.75651797]
E1 = -3.6832326034620677  E_coul = 0.9966728092065142
cycle= 3 E= -2.68655979425555  delta_E= -6.86e-07  |g|= 4.12e-05  |ddm|= 0.00916
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.84494176462753  LUMO = 1.68898560640876
  mo_energy =
[-0.84494176  1.68898561  5.75653765]
E1 = -3.683235849873935  E_coul = 0.9966760554267595
cycle= 4 E= -2.68655979444718  delta_E= -1.92e-10  |g|= 5.08e-08  |ddm|= 0.000222
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.683235849873935  E_coul = 0.9966760554267595
  HOMO = -0.844941869510208  LUMO = 1.68898561600657
  mo_energy =
[-0.84494187  1.68898562  5.75653771]
E1 = -3.683235860734141  E_coul = 0.9966760662869663
Extra cycle  E= -2.68655979444717  delta_E= 8.88e-16  |g|= 5.27e-09  |ddm|= 1.47e-07
    CPU time for scf_cycle      0.06 sec, wall time      0.06 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 273.9518883098533
E1 = -3.683235860734141  E_coul = 0.9966760662869663
init E= -2.68655979444717
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  HOMO = -0.844941864080105  LUMO = 1.6889856190573
  mo_energy =
[-0.84494186  1.68898562  5.75653771]
E1 = -3.6832358618307066  E_coul = 0.9966760673835315
cycle= 1 E= -2.68655979444718  delta_E= -4.44e-16  |g|= 6.1e-10  |ddm|= 2.09e-08
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -3.6832358618307066  E_coul = 0.9966760673835315
  HOMO = -0.844941863531822  LUMO = 1.68898561937795
  mo_energy =
[-0.84494186  1.68898562  5.75653772]
E1 = -3.6832358619458296  E_coul = 0.9966760674986542
Extra cycle  E= -2.68655979444718  delta_E= -4.44e-16  |g|= 7.43e-11  |ddm|= 2.8e-09
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
exp = [1.93911837 1.25163342 0.49473128]
grad_E = [-0.05001818 -0.02331488  0.04170704]
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:01:56 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  3.23486799855        1
[INPUT] 0    0    [1    /1   ]  1.97196005449        1
[INPUT] 0    0    [1    /1   ]  0.307120281386       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [3.234867998549931, 1.0]], [0, [1.971960054493957, 1.0]], [0, [0.3071202813859045, 1.0]]]}
ecp = {}
CPU time:         9.80
Set gradient conv threshold to 3.16228e-05
cond(S) = 76.54897446873503
E1 = -3.679148032598394  E_coul = 1.0015611775323277
init E= -2.67758685506607
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.853313237940695  LUMO = 1.56107602705675
  mo_energy =
[-0.85331324  1.56107603  7.95678947]
E1 = -3.6580561927184534  E_coul = 0.9475464204935764
cycle= 1 E= -2.71050977222488  delta_E= -0.0329  |g|= 0.0412  |ddm|= 0.398
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.88158655508983  LUMO = 1.54482904134984
  mo_energy =
[-0.88158656  1.54482904  7.8931721 ]
E1 = -3.6520379747316527  E_coul = 0.9412996585855656
cycle= 2 E= -2.71073831614609  delta_E= -0.000229  |g|= 0.00403  |ddm|= 0.0413
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.884978921821236  LUMO = 1.54193470015691
  mo_energy =
[-0.88497892  1.5419347   7.88504964]
E1 = -3.651494738707424  E_coul = 0.9407545520712415
cycle= 3 E= -2.71074018663618  delta_E= -1.87e-06  |g|= 9.47e-05  |ddm|= 0.00426
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.884995007618235  LUMO = 1.54191110679508
  mo_energy =
[-0.88499501  1.54191111  7.88500702]
E1 = -3.651490154227722  E_coul = 0.9407499669446078
cycle= 4 E= -2.71074018728311  delta_E= -6.47e-10  |g|= 7.13e-08  |ddm|= 8.62e-05
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.651490154227722  E_coul = 0.9407499669446078
  HOMO = -0.884995110169254  LUMO = 1.54191128167145
  mo_energy =
[-0.88499511  1.54191128  7.88500713]
E1 = -3.6514901377341324  E_coul = 0.9407499504510168
Extra cycle  E= -2.71074018728312  delta_E= -1.33e-15  |g|= 4.54e-09  |ddm|= 4.5e-08
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
exp = [3.234868   1.97196005 0.30712028]
E = -2.7107401872831156
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:01:56 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  3.23486799855        1
[INPUT] 0    0    [1    /1   ]  1.97196005449        1
[INPUT] 0    0    [1    /1   ]  0.307120281386       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [3.234867998549931, 1.0]], [0, [1.971960054493957, 1.0]], [0, [0.3071202813859045, 1.0]]]}
ecp = {}
CPU time:         9.94
Set gradient conv threshold to 3.16228e-05
cond(S) = 76.54897446873503
E1 = -3.679148032598394  E_coul = 1.0015611775323277
init E= -2.67758685506607
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.853313237940695  LUMO = 1.56107602705675
  mo_energy =
[-0.85331324  1.56107603  7.95678947]
E1 = -3.6580561927184534  E_coul = 0.9475464204935764
cycle= 1 E= -2.71050977222488  delta_E= -0.0329  |g|= 0.0412  |ddm|= 0.398
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.88158655508983  LUMO = 1.54482904134984
  mo_energy =
[-0.88158656  1.54482904  7.8931721 ]
E1 = -3.6520379747316527  E_coul = 0.9412996585855656
cycle= 2 E= -2.71073831614609  delta_E= -0.000229  |g|= 0.00403  |ddm|= 0.0413
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.884978921821236  LUMO = 1.54193470015691
  mo_energy =
[-0.88497892  1.5419347   7.88504964]
E1 = -3.651494738707424  E_coul = 0.9407545520712415
cycle= 3 E= -2.71074018663618  delta_E= -1.87e-06  |g|= 9.47e-05  |ddm|= 0.00426
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.884995007618235  LUMO = 1.54191110679508
  mo_energy =
[-0.88499501  1.54191111  7.88500702]
E1 = -3.651490154227722  E_coul = 0.9407499669446078
cycle= 4 E= -2.71074018728311  delta_E= -6.47e-10  |g|= 7.13e-08  |ddm|= 8.62e-05
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.651490154227722  E_coul = 0.9407499669446078
  HOMO = -0.884995110169254  LUMO = 1.54191128167145
  mo_energy =
[-0.88499511  1.54191128  7.88500713]
E1 = -3.6514901377341324  E_coul = 0.9407499504510168
Extra cycle  E= -2.71074018728312  delta_E= -1.33e-15  |g|= 4.54e-09  |ddm|= 4.5e-08
    CPU time for scf_cycle      0.06 sec, wall time      0.07 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 76.54897446873503
E1 = -3.6514901377341324  E_coul = 0.9407499504510168
init E= -2.71074018728312
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  HOMO = -0.884995118416049  LUMO = 1.54191127518596
  mo_energy =
[-0.88499512  1.54191128  7.88500711]
E1 = -3.651490136627415  E_coul = 0.9407499493442996
cycle= 1 E= -2.71074018728312  delta_E=    0  |g|= 3.57e-10  |ddm|= 3.86e-09
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -3.651490136627415  E_coul = 0.9407499493442996
  HOMO = -0.884995118969408  LUMO = 1.54191127474001
  mo_energy =
[-0.88499512  1.54191127  7.88500711]
E1 = -3.6514901365496306  E_coul = 0.9407499492665148
Extra cycle  E= -2.71074018728312  delta_E=    0  |g|= 3.31e-11  |ddm|= 3.57e-10
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
exp = [3.234868   1.97196005 0.30712028]
grad_E = [-0.02295086  0.04152368 -0.5158323 ]
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:01:58 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  3.28064061817        1
[INPUT] 0    0    [1    /1   ]  1.96284689995        1
[INPUT] 0    0    [1    /1   ]  0.482167867921       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [3.280640618173586, 1.0]], [0, [1.9628468999467776, 1.0]], [0, [0.48216786792145955, 1.0]]]}
ecp = {}
CPU time:        11.81
Set gradient conv threshold to 3.16228e-05
cond(S) = 102.66405269393884
E1 = -3.737375120885949  E_coul = 1.0174515932676378
init E= -2.71992352761831
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.861431633418462  LUMO = 2.12821081089381
  mo_energy =
[-0.86143163  2.12821081  8.66566803]
E1 = -3.764023714100778  E_coul = 1.0233655994408033
cycle= 1 E= -2.74065811465997  delta_E= -0.0207  |g|= 0.0228  |ddm|= 0.192
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.858662479114149  LUMO = 2.13946555611066
  mo_energy =
[-0.85866248  2.13946556  8.67099891]
E1 = -3.762431655154403  E_coul = 1.0217389033100956
cycle= 2 E= -2.74069275184431  delta_E= -3.46e-05  |g|= 0.00158  |ddm|= 0.0127
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.859534204119098  LUMO = 2.13890958064085
  mo_energy =
[-0.8595342   2.13890958  8.66900249]
E1 = -3.762323974396241  E_coul = 1.0216310623576788
cycle= 3 E= -2.74069291203856  delta_E= -1.6e-07  |g|= 9.76e-06  |ddm|= 0.000997
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.859530532514731  LUMO = 2.13891293692165
  mo_energy =
[-0.85953053  2.13891294  8.66901013]
E1 = -3.762324710501261  E_coul = 1.0216317984550745
cycle= 4 E= -2.74069291204619  delta_E= -7.62e-12  |g|= 1.53e-08  |ddm|= 1.23e-05
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.762324710501261  E_coul = 1.0216317984550745
  HOMO = -0.859530556795557  LUMO = 2.1389129379959
  mo_energy =
[-0.85953056  2.13891294  8.66901013]
E1 = -3.7623247133841775  E_coul = 1.021631801337991
Extra cycle  E= -2.74069291204619  delta_E=    0  |g|= 1.22e-09  |ddm|= 1.25e-08
    CPU time for scf_cycle      0.06 sec, wall time      0.06 sec
exp = [3.28064062 1.9628469  0.48216787]
E = -2.7406929120461863
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:01:59 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  3.28064061817        1
[INPUT] 0    0    [1    /1   ]  1.96284689995        1
[INPUT] 0    0    [1    /1   ]  0.482167867921       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [3.280640618173586, 1.0]], [0, [1.9628468999467776, 1.0]], [0, [0.48216786792145955, 1.0]]]}
ecp = {}
CPU time:        11.96
Set gradient conv threshold to 3.16228e-05
cond(S) = 102.66405269393884
E1 = -3.737375120885949  E_coul = 1.0174515932676378
init E= -2.71992352761831
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.861431633418462  LUMO = 2.12821081089381
  mo_energy =
[-0.86143163  2.12821081  8.66566803]
E1 = -3.764023714100778  E_coul = 1.0233655994408033
cycle= 1 E= -2.74065811465997  delta_E= -0.0207  |g|= 0.0228  |ddm|= 0.192
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.858662479114149  LUMO = 2.13946555611066
  mo_energy =
[-0.85866248  2.13946556  8.67099891]
E1 = -3.762431655154403  E_coul = 1.0217389033100956
cycle= 2 E= -2.74069275184431  delta_E= -3.46e-05  |g|= 0.00158  |ddm|= 0.0127
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.859534204119098  LUMO = 2.13890958064085
  mo_energy =
[-0.8595342   2.13890958  8.66900249]
E1 = -3.762323974396241  E_coul = 1.0216310623576788
cycle= 3 E= -2.74069291203856  delta_E= -1.6e-07  |g|= 9.76e-06  |ddm|= 0.000997
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.859530532514731  LUMO = 2.13891293692165
  mo_energy =
[-0.85953053  2.13891294  8.66901013]
E1 = -3.762324710501261  E_coul = 1.0216317984550745
cycle= 4 E= -2.74069291204619  delta_E= -7.62e-12  |g|= 1.53e-08  |ddm|= 1.23e-05
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.762324710501261  E_coul = 1.0216317984550745
  HOMO = -0.859530556795557  LUMO = 2.1389129379959
  mo_energy =
[-0.85953056  2.13891294  8.66901013]
E1 = -3.7623247133841775  E_coul = 1.021631801337991
Extra cycle  E= -2.74069291204619  delta_E=    0  |g|= 1.22e-09  |ddm|= 1.25e-08
    CPU time for scf_cycle      0.06 sec, wall time      0.06 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 102.66405269393884
E1 = -3.7623247133841775  E_coul = 1.021631801337991
init E= -2.74069291204619
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  HOMO = -0.859530555354099  LUMO = 2.13891293911607
  mo_energy =
[-0.85953056  2.13891294  8.66901014]
E1 = -3.762324713620693  E_coul = 1.0216318015745058
cycle= 1 E= -2.74069291204619  delta_E= -8.88e-16  |g|= 1.1e-10  |ddm|= 1.3e-09
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -3.762324713620693  E_coul = 1.0216318015745058
  HOMO = -0.859530555235841  LUMO = 2.13891293921023
  mo_energy =
[-0.85953056  2.13891294  8.66901014]
E1 = -3.7623247136407496  E_coul = 1.0216318015945627
Extra cycle  E= -2.74069291204619  delta_E=    0  |g|= 1.07e-11  |ddm|= 1.34e-10
    CPU time for scf_cycle      0.07 sec, wall time      0.08 sec
exp = [3.28064062 1.9628469  0.48216787]
grad_E = [-0.02407362  0.00072735  0.07000146]
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:01 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  3.74302126267        1
[INPUT] 0    0    [1    /1   ]  2.19169543097        1
[INPUT] 0    0    [1    /1   ]  0.479966355624       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [3.7430212626732526, 1.0]], [0, [2.191695430970099, 1.0]], [0, [0.4799663556241691, 1.0]]]}
ecp = {}
CPU time:        13.95
Set gradient conv threshold to 3.16228e-05
cond(S) = 84.49594650686221
E1 = -3.7503026776744934  E_coul = 1.0189804326520286
init E= -2.73132224502247
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.865425443631002  LUMO = 2.26439211357873
  mo_energy =
[-0.86542544  2.26439211  9.66249502]
E1 = -3.7742499961924345  E_coul = 1.0241971323329968
cycle= 1 E= -2.75005286385944  delta_E= -0.0187  |g|= 0.0182  |ddm|= 0.108
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.862939355523261  LUMO = 2.27472391623564
  mo_energy =
[-0.86293936  2.27472392  9.66594667]
E1 = -3.7725583044953104  E_coul = 1.0224809803228576
cycle= 2 E= -2.75007732417245  delta_E= -2.45e-05  |g|= 0.00115  |ddm|= 0.00648
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.863858061406292  LUMO = 2.27401923010635
  mo_energy =
[-0.86385806  2.27401923  9.66364077]
E1 = -3.7724359723720244  E_coul = 1.0223585457729225
cycle= 3 E= -2.7500774265991  delta_E= -1.02e-07  |g|= 4.81e-06  |ddm|= 0.000427
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.863859611294572  LUMO = 2.27401735505418
  mo_energy =
[-0.86385961  2.27401736  9.6636366 ]
E1 = -3.772435594908255  E_coul = 1.0223581683074165
cycle= 4 E= -2.75007742660084  delta_E= -1.74e-12  |g|= 9.1e-09  |ddm|= 4.81e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.772435594908255  E_coul = 1.0223581683074165
  HOMO = -0.863859629146712  LUMO = 2.27401735972781
  mo_energy =
[-0.86385963  2.27401736  9.6636366 ]
E1 = -3.7724355965620275  E_coul = 1.0223581699611883
Extra cycle  E= -2.75007742660084  delta_E= -8.88e-16  |g|= 6.8e-10  |ddm|= 6.29e-09
    CPU time for scf_cycle      0.07 sec, wall time      0.08 sec
exp = [3.74302126 2.19169543 0.47996636]
E = -2.750077426600839
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:01 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  3.74302126267        1
[INPUT] 0    0    [1    /1   ]  2.19169543097        1
[INPUT] 0    0    [1    /1   ]  0.479966355624       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [3.7430212626732526, 1.0]], [0, [2.191695430970099, 1.0]], [0, [0.4799663556241691, 1.0]]]}
ecp = {}
CPU time:        14.13
Set gradient conv threshold to 3.16228e-05
cond(S) = 84.49594650686221
E1 = -3.7503026776744934  E_coul = 1.0189804326520286
init E= -2.73132224502247
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.865425443631002  LUMO = 2.26439211357873
  mo_energy =
[-0.86542544  2.26439211  9.66249502]
E1 = -3.7742499961924345  E_coul = 1.0241971323329968
cycle= 1 E= -2.75005286385944  delta_E= -0.0187  |g|= 0.0182  |ddm|= 0.108
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.862939355523261  LUMO = 2.27472391623564
  mo_energy =
[-0.86293936  2.27472392  9.66594667]
E1 = -3.7725583044953104  E_coul = 1.0224809803228576
cycle= 2 E= -2.75007732417245  delta_E= -2.45e-05  |g|= 0.00115  |ddm|= 0.00648
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.863858061406292  LUMO = 2.27401923010635
  mo_energy =
[-0.86385806  2.27401923  9.66364077]
E1 = -3.7724359723720244  E_coul = 1.0223585457729225
cycle= 3 E= -2.7500774265991  delta_E= -1.02e-07  |g|= 4.81e-06  |ddm|= 0.000427
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.863859611294572  LUMO = 2.27401735505418
  mo_energy =
[-0.86385961  2.27401736  9.6636366 ]
E1 = -3.772435594908255  E_coul = 1.0223581683074165
cycle= 4 E= -2.75007742660084  delta_E= -1.74e-12  |g|= 9.1e-09  |ddm|= 4.81e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.772435594908255  E_coul = 1.0223581683074165
  HOMO = -0.863859629146712  LUMO = 2.27401735972781
  mo_energy =
[-0.86385963  2.27401736  9.6636366 ]
E1 = -3.7724355965620275  E_coul = 1.0223581699611883
Extra cycle  E= -2.75007742660084  delta_E= -8.88e-16  |g|= 6.8e-10  |ddm|= 6.29e-09
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 84.49594650686221
E1 = -3.7724355965620275  E_coul = 1.0223581699611883
init E= -2.75007742660084
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  HOMO = -0.863859628319825  LUMO = 2.2740173604316
  mo_energy =
[-0.86385963  2.27401736  9.6636366 ]
E1 = -3.7724355966903107  E_coul = 1.0223581700894722
cycle= 1 E= -2.75007742660084  delta_E= 8.88e-16  |g|= 5.7e-11  |ddm|= 5.97e-10
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -3.7724355966903107  E_coul = 1.0223581700894722
  HOMO = -0.863859628255683  LUMO = 2.2740173604873
  mo_energy =
[-0.86385963  2.27401736  9.6636366 ]
E1 = -3.7724355967005505  E_coul = 1.0223581700997117
Extra cycle  E= -2.75007742660084  delta_E= -4.44e-16  |g|= 5.15e-12  |ddm|= 5.67e-11
    CPU time for scf_cycle      0.08 sec, wall time      0.09 sec
exp = [3.74302126 2.19169543 0.47996636]
grad_E = [-0.01968685  0.00637882  0.04771088]
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:03 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  4.82603939442        1
[INPUT] 0    0    [1    /1   ]  2.70338945048        1
[INPUT] 0    0    [1    /1   ]  0.475242440338       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [4.826039394424967, 1.0]], [0, [2.703389450484428, 1.0]], [0, [0.475242440337518, 1.0]]]}
ecp = {}
CPU time:        16.53
Set gradient conv threshold to 3.16228e-05
cond(S) = 60.23083354553567
E1 = -3.764285476124196  E_coul = 1.0200495109790055
init E= -2.74423596514519
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.870385146835679  LUMO = 2.56372796400766
  mo_energy =
[-0.87038515  2.56372796 11.98937175]
E1 = -3.779438902516573  E_coul = 1.0184144695462198
cycle= 1 E= -2.76102443297035  delta_E= -0.0168  |g|= 0.0126  |ddm|= 0.0674
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.871316390428089  LUMO = 2.56914545690348
  mo_energy =
[-0.87131639  2.56914546 11.98192983]
E1 = -3.777268362330738  E_coul = 1.0162195080028127
cycle= 2 E= -2.76104885432793  delta_E= -2.44e-05  |g|= 0.000893  |ddm|= 0.00809
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.872491698503402  LUMO = 2.56793727230827
  mo_energy =
[-0.8724917   2.56793727 11.97853019]
E1 = -3.7771037260672014  E_coul = 1.0160547479766608
cycle= 3 E= -2.76104897809054  delta_E= -1.24e-07  |g|= 1.76e-05  |ddm|= 0.000694
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.872497644145722  LUMO = 2.56792964249331
  mo_energy =
[-0.87249764  2.56792964 11.97851381]
E1 = -3.777102640396295  E_coul = 1.0160536622880416
cycle= 4 E= -2.76104897810825  delta_E= -1.77e-11  |g|= 1.13e-09  |ddm|= 1.17e-05
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.777102640396295  E_coul = 1.0160536622880416
  HOMO = -0.872497657910107  LUMO = 2.56792965605955
  mo_energy =
[-0.87249766  2.56792966 11.97851381]
E1 = -3.7771026405690216  E_coul = 1.0160536624607703
Extra cycle  E= -2.76104897810825  delta_E= 2.22e-15  |g|= 8.99e-11  |ddm|= 8.73e-10
    CPU time for scf_cycle      0.06 sec, wall time      0.07 sec
exp = [4.82603939 2.70338945 0.47524244]
E = -2.761048978108251
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:03 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  4.82603939442        1
[INPUT] 0    0    [1    /1   ]  2.70338945048        1
[INPUT] 0    0    [1    /1   ]  0.475242440338       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [4.826039394424967, 1.0]], [0, [2.703389450484428, 1.0]], [0, [0.475242440337518, 1.0]]]}
ecp = {}
CPU time:        16.71
Set gradient conv threshold to 3.16228e-05
cond(S) = 60.23083354553567
E1 = -3.764285476124196  E_coul = 1.0200495109790055
init E= -2.74423596514519
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.870385146835679  LUMO = 2.56372796400766
  mo_energy =
[-0.87038515  2.56372796 11.98937175]
E1 = -3.779438902516573  E_coul = 1.0184144695462198
cycle= 1 E= -2.76102443297035  delta_E= -0.0168  |g|= 0.0126  |ddm|= 0.0674
    CPU time for cycle= 1      0.01 sec, wall time      0.02 sec
  HOMO = -0.871316390428089  LUMO = 2.56914545690348
  mo_energy =
[-0.87131639  2.56914546 11.98192983]
E1 = -3.777268362330738  E_coul = 1.0162195080028127
cycle= 2 E= -2.76104885432793  delta_E= -2.44e-05  |g|= 0.000893  |ddm|= 0.00809
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.872491698503402  LUMO = 2.56793727230827
  mo_energy =
[-0.8724917   2.56793727 11.97853019]
E1 = -3.7771037260672014  E_coul = 1.0160547479766608
cycle= 3 E= -2.76104897809054  delta_E= -1.24e-07  |g|= 1.76e-05  |ddm|= 0.000694
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.872497644145722  LUMO = 2.56792964249331
  mo_energy =
[-0.87249764  2.56792964 11.97851381]
E1 = -3.777102640396295  E_coul = 1.0160536622880416
cycle= 4 E= -2.76104897810825  delta_E= -1.77e-11  |g|= 1.13e-09  |ddm|= 1.17e-05
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.777102640396295  E_coul = 1.0160536622880416
  HOMO = -0.872497657910107  LUMO = 2.56792965605955
  mo_energy =
[-0.87249766  2.56792966 11.97851381]
E1 = -3.7771026405690216  E_coul = 1.0160536624607703
Extra cycle  E= -2.76104897810825  delta_E= 2.22e-15  |g|= 8.99e-11  |ddm|= 8.73e-10
    CPU time for scf_cycle      0.09 sec, wall time      0.09 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 60.23083354553567
E1 = -3.7771026405690216  E_coul = 1.0160536624607703
init E= -2.76104897810825
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  HOMO = -0.872497657823743  LUMO = 2.56792965615143
  mo_energy =
[-0.87249766  2.56792966 11.97851381]
E1 = -3.7771026405816994  E_coul = 1.016053662473447
cycle= 1 E= -2.76104897810825  delta_E= -1.33e-15  |g|= 7.21e-12  |ddm|= 6.94e-11
    CPU time for cycle= 1      0.02 sec, wall time      0.02 sec
E1 = -3.7771026405816994  E_coul = 1.016053662473447
  HOMO = -0.872497657817403  LUMO = 2.56792965615823
  mo_energy =
[-0.87249766  2.56792966 11.97851381]
E1 = -3.7771026405826396  E_coul = 1.016053662474388
Extra cycle  E= -2.76104897810825  delta_E= 8.88e-16  |g|= 5.71e-13  |ddm|= 5.51e-12
    CPU time for scf_cycle      0.13 sec, wall time      0.16 sec
exp = [4.82603939 2.70338945 0.47524244]
grad_E = [-0.01262594  0.01774281 -0.04288945]
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:06 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  5.35190100056        1
[INPUT] 0    0    [1    /1   ]  2.92947295039        1
[INPUT] 0    0    [1    /1   ]  0.496099341948       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [5.35190100056333, 1.0]], [0, [2.9294729503860317, 1.0]], [0, [0.4960993419481079, 1.0]]]}
ecp = {}
CPU time:        19.46
Set gradient conv threshold to 3.16228e-05
cond(S) = 54.2113507935492
E1 = -3.7664321820580873  E_coul = 1.0212738012502733
init E= -2.74515838080781
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.87114058388238  LUMO = 2.77657747086667
  mo_energy =
[-0.87114058  2.77657747 13.1789062 ]
E1 = -3.7896224258755846  E_coul = 1.0259329727513504
cycle= 1 E= -2.76368945312423  delta_E= -0.0185  |g|= 0.0123  |ddm|= 0.056
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.868888360711313  LUMO = 2.78597103893258
  mo_energy =
[-0.86888836  2.78597104 13.17876103]
E1 = -3.787635804440549  E_coul = 1.0239247331932668
cycle= 2 E= -2.76371107124728  delta_E= -2.16e-05  |g|= 0.000834  |ddm|= 0.00716
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.869961809479185  LUMO = 2.7847946129119
  mo_energy =
[-0.86996181  2.78479461 13.17547727]
E1 = -3.7874896121418833  E_coul = 1.0237784386848785
cycle= 3 E= -2.76371117345701  delta_E= -1.02e-07  |g|= 1.4e-05  |ddm|= 0.000583
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.869966782691155  LUMO = 2.78478796212832
  mo_energy =
[-0.86996678  2.78478796 13.17546294]
E1 = -3.7874887590646034  E_coul = 1.0237775855971611
cycle= 4 E= -2.76371117346744  delta_E= -1.04e-11  |g|= 1.65e-09  |ddm|= 8.38e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.7874887590646034  E_coul = 1.0237775855971611
  HOMO = -0.869966793935143  LUMO = 2.78478797239382
  mo_energy =
[-0.86996679  2.78478797 13.17546294]
E1 = -3.787488759331405  E_coul = 1.0237775858639622
Extra cycle  E= -2.76371117346744  delta_E= -8.88e-16  |g|= 1.21e-10  |ddm|= 1.12e-09
    CPU time for scf_cycle      0.08 sec, wall time      0.08 sec
exp = [5.351901   2.92947295 0.49609934]
E = -2.763711173467443
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:07 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  5.35190100056        1
[INPUT] 0    0    [1    /1   ]  2.92947295039        1
[INPUT] 0    0    [1    /1   ]  0.496099341948       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [5.35190100056333, 1.0]], [0, [2.9294729503860317, 1.0]], [0, [0.4960993419481079, 1.0]]]}
ecp = {}
CPU time:        19.70
Set gradient conv threshold to 3.16228e-05
cond(S) = 54.2113507935492
E1 = -3.7664321820580873  E_coul = 1.0212738012502733
init E= -2.74515838080781
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.87114058388238  LUMO = 2.77657747086667
  mo_energy =
[-0.87114058  2.77657747 13.1789062 ]
E1 = -3.7896224258755846  E_coul = 1.0259329727513504
cycle= 1 E= -2.76368945312423  delta_E= -0.0185  |g|= 0.0123  |ddm|= 0.056
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.868888360711313  LUMO = 2.78597103893258
  mo_energy =
[-0.86888836  2.78597104 13.17876103]
E1 = -3.787635804440549  E_coul = 1.0239247331932668
cycle= 2 E= -2.76371107124728  delta_E= -2.16e-05  |g|= 0.000834  |ddm|= 0.00716
    CPU time for cycle= 2      0.02 sec, wall time      0.02 sec
  HOMO = -0.869961809479185  LUMO = 2.7847946129119
  mo_energy =
[-0.86996181  2.78479461 13.17547727]
E1 = -3.7874896121418833  E_coul = 1.0237784386848785
cycle= 3 E= -2.76371117345701  delta_E= -1.02e-07  |g|= 1.4e-05  |ddm|= 0.000583
    CPU time for cycle= 3      0.01 sec, wall time      0.02 sec
  HOMO = -0.869966782691155  LUMO = 2.78478796212832
  mo_energy =
[-0.86996678  2.78478796 13.17546294]
E1 = -3.7874887590646034  E_coul = 1.0237775855971611
cycle= 4 E= -2.76371117346744  delta_E= -1.04e-11  |g|= 1.65e-09  |ddm|= 8.38e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.7874887590646034  E_coul = 1.0237775855971611
  HOMO = -0.869966793935143  LUMO = 2.78478797239382
  mo_energy =
[-0.86996679  2.78478797 13.17546294]
E1 = -3.787488759331405  E_coul = 1.0237775858639622
Extra cycle  E= -2.76371117346744  delta_E= -8.88e-16  |g|= 1.21e-10  |ddm|= 1.12e-09
    CPU time for scf_cycle      0.08 sec, wall time      0.09 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 54.2113507935492
E1 = -3.787488759331405  E_coul = 1.0237775858639622
init E= -2.76371117346744
    CPU time for initialize scf      0.04 sec, wall time      0.04 sec
  HOMO = -0.869966793801743  LUMO = 2.78478797254277
  mo_energy =
[-0.86996679  2.78478797 13.17546294]
E1 = -3.7874887593500017  E_coul = 1.023777585882559
cycle= 1 E= -2.76371117346744  delta_E=    0  |g|= 9.09e-12  |ddm|= 8.52e-11
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -3.7874887593500017  E_coul = 1.023777585882559
  HOMO = -0.869966793792444  LUMO = 2.78478797255324
  mo_energy =
[-0.86996679  2.78478797 13.17546294]
E1 = -3.7874887593513136  E_coul = 1.0237775858838698
Extra cycle  E= -2.76371117346744  delta_E= -8.88e-16  |g|= 6.91e-13  |ddm|= 6.45e-12
    CPU time for scf_cycle      0.09 sec, wall time      0.09 sec
exp = [5.351901   2.92947295 0.49609934]
grad_E = [-0.01051729  0.0182774  -0.02231804]
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:09 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  5.94923396325        1
[INPUT] 0    0    [1    /1   ]  3.16012196127        1
[INPUT] 0    0    [1    /1   ]  0.519482923476       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [5.949233963254368, 1.0]], [0, [3.1601219612693026, 1.0]], [0, [0.5194829234764257, 1.0]]]}
ecp = {}
CPU time:        22.03
Set gradient conv threshold to 3.16228e-05
cond(S) = 48.169748327010986
E1 = -3.7670277115427813  E_coul = 1.0225222871268775
init E= -2.7445054244159
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.871419337341818  LUMO = 3.00801501771082
  mo_energy =
[-0.87141934  3.00801502 14.48412439]
E1 = -3.800383910465278  E_coul = 1.034981696792947
cycle= 1 E= -2.76540221367233  delta_E= -0.0209  |g|= 0.0121  |ddm|= 0.0423
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.865219007206188  LUMO = 3.02290884597745
  mo_energy =
[-0.86521901  3.02290885 14.49391542]
E1 = -3.7985989761174697  E_coul = 1.033178114157629
cycle= 2 E= -2.76542086195984  delta_E= -1.86e-05  |g|= 0.000774  |ddm|= 0.00605
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.866181396134725  LUMO = 3.0217911550396
  mo_energy =
[-0.8661814   3.02179116 14.49080019]
E1 = -3.798471291666421  E_coul = 1.033050347497713
cycle= 3 E= -2.76542094416871  delta_E= -8.22e-08  |g|= 1.12e-05  |ddm|= 0.000472
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.866185632527674  LUMO = 3.02178527802313
  mo_energy =
[-0.86618563  3.02178528 14.4907874 ]
E1 = -3.798470605211058  E_coul = 1.033049661036023
cycle= 4 E= -2.76542094417504  delta_E= -6.33e-12  |g|= 2.06e-09  |ddm|= 6.05e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.798470605211058  E_coul = 1.033049661036023
  HOMO = -0.866185641569506  LUMO = 3.02178528534656
  mo_energy =
[-0.86618564  3.02178529 14.4907874 ]
E1 = -3.7984706055294137  E_coul = 1.0330496613543774
Extra cycle  E= -2.76542094417504  delta_E= -1.33e-15  |g|= 1.42e-10  |ddm|= 1.23e-09
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
exp = [5.94923396 3.16012196 0.51948292]
E = -2.7654209441750366
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:09 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  5.94923396325        1
[INPUT] 0    0    [1    /1   ]  3.16012196127        1
[INPUT] 0    0    [1    /1   ]  0.519482923476       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [5.949233963254368, 1.0]], [0, [3.1601219612693026, 1.0]], [0, [0.5194829234764257, 1.0]]]}
ecp = {}
CPU time:        22.27
Set gradient conv threshold to 3.16228e-05
cond(S) = 48.169748327010986
E1 = -3.7670277115427813  E_coul = 1.0225222871268775
init E= -2.7445054244159
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.871419337341818  LUMO = 3.00801501771082
  mo_energy =
[-0.87141934  3.00801502 14.48412439]
E1 = -3.800383910465278  E_coul = 1.034981696792947
cycle= 1 E= -2.76540221367233  delta_E= -0.0209  |g|= 0.0121  |ddm|= 0.0423
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.865219007206188  LUMO = 3.02290884597745
  mo_energy =
[-0.86521901  3.02290885 14.49391542]
E1 = -3.7985989761174697  E_coul = 1.033178114157629
cycle= 2 E= -2.76542086195984  delta_E= -1.86e-05  |g|= 0.000774  |ddm|= 0.00605
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.866181396134725  LUMO = 3.0217911550396
  mo_energy =
[-0.8661814   3.02179116 14.49080019]
E1 = -3.798471291666421  E_coul = 1.033050347497713
cycle= 3 E= -2.76542094416871  delta_E= -8.22e-08  |g|= 1.12e-05  |ddm|= 0.000472
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.866185632527674  LUMO = 3.02178527802313
  mo_energy =
[-0.86618563  3.02178528 14.4907874 ]
E1 = -3.798470605211058  E_coul = 1.033049661036023
cycle= 4 E= -2.76542094417504  delta_E= -6.33e-12  |g|= 2.06e-09  |ddm|= 6.05e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.798470605211058  E_coul = 1.033049661036023
  HOMO = -0.866185641569506  LUMO = 3.02178528534656
  mo_energy =
[-0.86618564  3.02178529 14.4907874 ]
E1 = -3.7984706055294137  E_coul = 1.0330496613543774
Extra cycle  E= -2.76542094417504  delta_E= -1.33e-15  |g|= 1.42e-10  |ddm|= 1.23e-09
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 48.169748327010986
E1 = -3.7984706055294137  E_coul = 1.0330496613543774
init E= -2.76542094417504
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  HOMO = -0.866185641410329  LUMO = 3.02178528553435
  mo_energy =
[-0.86618564  3.02178529 14.4907874 ]
E1 = -3.7984706055509316  E_coul = 1.0330496613758962
cycle= 1 E= -2.76542094417504  delta_E= 8.88e-16  |g|= 1.01e-11  |ddm|= 8.96e-11
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -3.7984706055509316  E_coul = 1.0330496613758962
  HOMO = -0.866185641399568  LUMO = 3.02178528554713
  mo_energy =
[-0.86618564  3.02178529 14.4907874 ]
E1 = -3.7984706055523985  E_coul = 1.0330496613773639
Extra cycle  E= -2.76542094417503  delta_E= 8.88e-16  |g|= 7.27e-13  |ddm|= 6.52e-12
    CPU time for scf_cycle      0.08 sec, wall time      0.08 sec
exp = [5.94923396 3.16012196 0.51948292]
grad_E = [-0.00882534  0.01837624  0.00625758]
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:12 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  6.31509927005        1
[INPUT] 0    0    [1    /1   ]  3.27173843156        1
[INPUT] 0    0    [1    /1   ]  0.528470238206       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [6.315099270052806, 1.0]], [0, [3.2717384315592515, 1.0]], [0, [0.5284702382058004, 1.0]]]}
ecp = {}
CPU time:        24.56
Set gradient conv threshold to 3.16228e-05
cond(S) = 44.05083950211601
E1 = -3.767395819019447  E_coul = 1.0229953721426528
init E= -2.74440044687679
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.871658951772122  LUMO = 3.11787630488494
  mo_energy =
[-0.87165895  3.1178763  15.20279767]
E1 = -3.8045874175291483  E_coul = 1.0382681876447917
cycle= 1 E= -2.76631922988436  delta_E= -0.0219  |g|= 0.012  |ddm|= 0.0398
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.864033953595828  LUMO = 3.13489794146647
  mo_energy =
[-0.86403395  3.13489794 15.21629852]
E1 = -3.8028581004267106  E_coul = 1.0365209066542513
cycle= 2 E= -2.76633719377246  delta_E= -1.8e-05  |g|= 0.000763  |ddm|= 0.00586
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.864965758660516  LUMO = 3.13377979206912
  mo_energy =
[-0.86496576  3.13377979 15.21319552]
E1 = -3.8027357687573837  E_coul = 1.0363984973855893
cycle= 3 E= -2.76633727137179  delta_E= -7.76e-08  |g|= 1.01e-05  |ddm|= 0.000448
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.864969688720995  LUMO = 3.13377421574112
  mo_energy =
[-0.86496969  3.13377422 15.21318334]
E1 = -3.8027351487623107  E_coul = 1.0363978773854785
cycle= 4 E= -2.76633727137683  delta_E= -5.04e-12  |g|= 2.03e-09  |ddm|= 5.13e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.8027351487623107  E_coul = 1.0363978773854785
  HOMO = -0.864969696995679  LUMO = 3.13377422233768
  mo_energy =
[-0.8649697   3.13377422 15.21318334]
E1 = -3.8027351490686927  E_coul = 1.03639787769186
Extra cycle  E= -2.76633727137683  delta_E= -4.44e-16  |g|= 1.38e-10  |ddm|= 1.16e-09
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
exp = [6.31509927 3.27173843 0.52847024]
E = -2.7663372713768326
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:12 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  6.31509927005        1
[INPUT] 0    0    [1    /1   ]  3.27173843156        1
[INPUT] 0    0    [1    /1   ]  0.528470238206       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [6.315099270052806, 1.0]], [0, [3.2717384315592515, 1.0]], [0, [0.5284702382058004, 1.0]]]}
ecp = {}
CPU time:        24.80
Set gradient conv threshold to 3.16228e-05
cond(S) = 44.05083950211601
E1 = -3.767395819019447  E_coul = 1.0229953721426528
init E= -2.74440044687679
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.871658951772122  LUMO = 3.11787630488494
  mo_energy =
[-0.87165895  3.1178763  15.20279767]
E1 = -3.8045874175291483  E_coul = 1.0382681876447917
cycle= 1 E= -2.76631922988436  delta_E= -0.0219  |g|= 0.012  |ddm|= 0.0398
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.864033953595828  LUMO = 3.13489794146647
  mo_energy =
[-0.86403395  3.13489794 15.21629852]
E1 = -3.8028581004267106  E_coul = 1.0365209066542513
cycle= 2 E= -2.76633719377246  delta_E= -1.8e-05  |g|= 0.000763  |ddm|= 0.00586
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.864965758660516  LUMO = 3.13377979206912
  mo_energy =
[-0.86496576  3.13377979 15.21319552]
E1 = -3.8027357687573837  E_coul = 1.0363984973855893
cycle= 3 E= -2.76633727137179  delta_E= -7.76e-08  |g|= 1.01e-05  |ddm|= 0.000448
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.864969688720995  LUMO = 3.13377421574112
  mo_energy =
[-0.86496969  3.13377422 15.21318334]
E1 = -3.8027351487623107  E_coul = 1.0363978773854785
cycle= 4 E= -2.76633727137683  delta_E= -5.04e-12  |g|= 2.03e-09  |ddm|= 5.13e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.8027351487623107  E_coul = 1.0363978773854785
  HOMO = -0.864969696995679  LUMO = 3.13377422233768
  mo_energy =
[-0.8649697   3.13377422 15.21318334]
E1 = -3.8027351490686927  E_coul = 1.03639787769186
Extra cycle  E= -2.76633727137683  delta_E= -4.44e-16  |g|= 1.38e-10  |ddm|= 1.16e-09
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 44.05083950211601
E1 = -3.8027351490686927  E_coul = 1.03639787769186
init E= -2.76633727137683
    CPU time for initialize scf      0.04 sec, wall time      0.04 sec
  HOMO = -0.864969696842486  LUMO = 3.13377422252416
  mo_energy =
[-0.8649697   3.13377422 15.21318334]
E1 = -3.8027351490891443  E_coul = 1.0363978777123113
cycle= 1 E= -2.76633727137683  delta_E= -4.44e-16  |g|= 9.64e-12  |ddm|= 8.32e-11
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -3.8027351490891443  E_coul = 1.0363978777123113
  HOMO = -0.86496969683226  LUMO = 3.13377422253668
  mo_energy =
[-0.8649697   3.13377422 15.21318334]
E1 = -3.802735149090521  E_coul = 1.0363978777136877
Extra cycle  E= -2.76633727137683  delta_E=    0  |g|= 6.8e-13  |ddm|= 5.91e-12
    CPU time for scf_cycle      0.08 sec, wall time      0.08 sec
exp = [6.31509927 3.27173843 0.52847024]
grad_E = [-0.00809617  0.0190299   0.01320415]
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:14 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  7.0488437157         1
[INPUT] 0    0    [1    /1   ]  3.42756214684        1
[INPUT] 0    0    [1    /1   ]  0.540347839315       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [7.048843715696441, 1.0]], [0, [3.4275621468415913, 1.0]], [0, [0.540347839315285, 1.0]]]}
ecp = {}
CPU time:        26.95
Set gradient conv threshold to 3.16228e-05
cond(S) = 36.07890536340407
E1 = -3.768962238587935  E_coul = 1.0236939780518308
init E= -2.7452682605361
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.872470371331674  LUMO = 3.2818908341884
  mo_energy =
[-0.87247037  3.28189083 16.4728305 ]
E1 = -3.8114201347803345  E_coul = 1.0428322755491284
cycle= 1 E= -2.76858785923121  delta_E= -0.0233  |g|= 0.0117  |ddm|= 0.0374
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.862885756739878  LUMO = 3.30194276263131
  mo_energy =
[-0.86288576  3.30194276 16.49174134]
E1 = -3.809767555880517  E_coul = 1.0411627405950967
cycle= 2 E= -2.76860481528542  delta_E= -1.7e-05  |g|= 0.000745  |ddm|= 0.00566
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.863775424217776  LUMO = 3.30081801221843
  mo_energy =
[-0.86377542  3.30081801 16.48863837]
E1 = -3.809652590362847  E_coul = 1.0410477037106631
cycle= 3 E= -2.76860488665218  delta_E= -7.14e-08  |g|= 8.43e-06  |ddm|= 0.000417
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.863778843568444  LUMO = 3.30081298131402
  mo_energy =
[-0.86377884  3.30081298 16.48862727]
E1 = -3.8096520719384315  E_coul = 1.0410471852828866
cycle= 4 E= -2.76860488665554  delta_E= -3.36e-12  |g|= 1.87e-09  |ddm|= 3.79e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.8096520719384315  E_coul = 1.0410471852828866
  HOMO = -0.863778850686328  LUMO = 3.30081298701529
  mo_energy =
[-0.86377885  3.30081299 16.48862727]
E1 = -3.8096520722090967  E_coul = 1.0410471855535515
Extra cycle  E= -2.76860488665555  delta_E= -4.44e-16  |g|= 1.25e-10  |ddm|= 1.01e-09
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
exp = [7.04884372 3.42756215 0.54034784]
E = -2.7686048866555453
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:14 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  7.0488437157         1
[INPUT] 0    0    [1    /1   ]  3.42756214684        1
[INPUT] 0    0    [1    /1   ]  0.540347839315       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [7.048843715696441, 1.0]], [0, [3.4275621468415913, 1.0]], [0, [0.540347839315285, 1.0]]]}
ecp = {}
CPU time:        27.20
Set gradient conv threshold to 3.16228e-05
cond(S) = 36.07890536340407
E1 = -3.768962238587935  E_coul = 1.0236939780518308
init E= -2.7452682605361
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.872470371331674  LUMO = 3.2818908341884
  mo_energy =
[-0.87247037  3.28189083 16.4728305 ]
E1 = -3.8114201347803345  E_coul = 1.0428322755491284
cycle= 1 E= -2.76858785923121  delta_E= -0.0233  |g|= 0.0117  |ddm|= 0.0374
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.862885756739878  LUMO = 3.30194276263131
  mo_energy =
[-0.86288576  3.30194276 16.49174134]
E1 = -3.809767555880517  E_coul = 1.0411627405950967
cycle= 2 E= -2.76860481528542  delta_E= -1.7e-05  |g|= 0.000745  |ddm|= 0.00566
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.863775424217776  LUMO = 3.30081801221843
  mo_energy =
[-0.86377542  3.30081801 16.48863837]
E1 = -3.809652590362847  E_coul = 1.0410477037106631
cycle= 3 E= -2.76860488665218  delta_E= -7.14e-08  |g|= 8.43e-06  |ddm|= 0.000417
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.863778843568444  LUMO = 3.30081298131402
  mo_energy =
[-0.86377884  3.30081298 16.48862727]
E1 = -3.8096520719384315  E_coul = 1.0410471852828866
cycle= 4 E= -2.76860488665554  delta_E= -3.36e-12  |g|= 1.87e-09  |ddm|= 3.79e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.8096520719384315  E_coul = 1.0410471852828866
  HOMO = -0.863778850686328  LUMO = 3.30081298701529
  mo_energy =
[-0.86377885  3.30081299 16.48862727]
E1 = -3.8096520722090967  E_coul = 1.0410471855535515
Extra cycle  E= -2.76860488665555  delta_E= -4.44e-16  |g|= 1.25e-10  |ddm|= 1.01e-09
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 36.07890536340407
E1 = -3.8096520722090967  E_coul = 1.0410471855535515
init E= -2.76860488665555
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  HOMO = -0.863778850550995  LUMO = 3.30081298718835
  mo_energy =
[-0.86377885  3.30081299 16.48862727]
E1 = -3.809652072226809  E_coul = 1.0410471855712646
cycle= 1 E= -2.76860488665554  delta_E= 8.88e-16  |g|= 8.45e-12  |ddm|= 6.92e-11
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -3.809652072226809  E_coul = 1.0410471855712646
  HOMO = -0.863778850542143  LUMO = 3.30081298719972
  mo_energy =
[-0.86377885  3.30081299 16.48862727]
E1 = -3.809652072227977  E_coul = 1.041047185572432
Extra cycle  E= -2.76860488665555  delta_E= -8.88e-16  |g|= 5.74e-13  |ddm|= 4.75e-12
    CPU time for scf_cycle      0.08 sec, wall time      0.08 sec
exp = [7.04884372 3.42756215 0.54034784]
grad_E = [-0.00711796  0.02072237  0.02037149]
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:17 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  8.46998864645        1
[INPUT] 0    0    [1    /1   ]  3.58511518195        1
[INPUT] 0    0    [1    /1   ]  0.553593562063       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [8.469988646453423, 1.0]], [0, [3.5851151819541696, 1.0]], [0, [0.5535935620632598, 1.0]]]}
ecp = {}
CPU time:        29.44
Set gradient conv threshold to 3.16228e-05
cond(S) = 25.180015536905803
E1 = -3.7737775101406887  E_coul = 1.0246972166528718
init E= -2.74908029348782
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  HOMO = -0.874729523744655  LUMO = 3.47825739364403
  mo_energy =
[-0.87472952  3.47825739 18.55467441]
E1 = -3.823215684201141  E_coul = 1.049187081288411
cycle= 1 E= -2.77402860291273  delta_E= -0.0249  |g|= 0.011  |ddm|= 0.0326
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.86242769634439  LUMO = 3.5026190561087
  mo_energy =
[-0.8624277   3.50261906 18.58207479]
E1 = -3.821702266515467  E_coul = 1.047658913474817
cycle= 2 E= -2.77404335304065  delta_E= -1.48e-05  |g|= 0.000701  |ddm|= 0.00517
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.863241290510883  LUMO = 3.5015217262603
  mo_energy =
[-0.86324129  3.50152173 18.57903881]
E1 = -3.821599353304909  E_coul = 1.0475559404246642
cycle= 3 E= -2.77404341288024  delta_E= -5.98e-08  |g|= 6.03e-06  |ddm|= 0.000363
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.863243921278698  LUMO = 3.50151767894018
  mo_energy =
[-0.86324392  3.50151768 18.57902962]
E1 = -3.821598972415514  E_coul = 1.0475555595336186
cycle= 4 E= -2.7740434128819  delta_E= -1.65e-12  |g|= 1.54e-09  |ddm|= 2.27e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.821598972415514  E_coul = 1.0475555595336186
  HOMO = -0.863243926674136  LUMO = 3.50151768333134
  mo_energy =
[-0.86324393  3.50151768 18.57902962]
E1 = -3.8215989726275437  E_coul = 1.0475555597456476
Extra cycle  E= -2.7740434128819  delta_E= -4.44e-16  |g|= 9.96e-11  |ddm|= 7.51e-10
    CPU time for scf_cycle      0.08 sec, wall time      0.08 sec
exp = [8.46998865 3.58511518 0.55359356]
E = -2.774043412881896
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:17 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  8.46998864645        1
[INPUT] 0    0    [1    /1   ]  3.58511518195        1
[INPUT] 0    0    [1    /1   ]  0.553593562063       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [8.469988646453423, 1.0]], [0, [3.5851151819541696, 1.0]], [0, [0.5535935620632598, 1.0]]]}
ecp = {}
CPU time:        29.72
Set gradient conv threshold to 3.16228e-05
cond(S) = 25.180015536905803
E1 = -3.7737775101406887  E_coul = 1.0246972166528718
init E= -2.74908029348782
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.874729523744655  LUMO = 3.47825739364403
  mo_energy =
[-0.87472952  3.47825739 18.55467441]
E1 = -3.823215684201141  E_coul = 1.049187081288411
cycle= 1 E= -2.77402860291273  delta_E= -0.0249  |g|= 0.011  |ddm|= 0.0326
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.86242769634439  LUMO = 3.5026190561087
  mo_energy =
[-0.8624277   3.50261906 18.58207479]
E1 = -3.821702266515467  E_coul = 1.047658913474817
cycle= 2 E= -2.77404335304065  delta_E= -1.48e-05  |g|= 0.000701  |ddm|= 0.00517
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.863241290510883  LUMO = 3.5015217262603
  mo_energy =
[-0.86324129  3.50152173 18.57903881]
E1 = -3.821599353304909  E_coul = 1.0475559404246642
cycle= 3 E= -2.77404341288024  delta_E= -5.98e-08  |g|= 6.03e-06  |ddm|= 0.000363
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.863243921278698  LUMO = 3.50151767894018
  mo_energy =
[-0.86324392  3.50151768 18.57902962]
E1 = -3.821598972415514  E_coul = 1.0475555595336186
cycle= 4 E= -2.7740434128819  delta_E= -1.65e-12  |g|= 1.54e-09  |ddm|= 2.27e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.821598972415514  E_coul = 1.0475555595336186
  HOMO = -0.863243926674136  LUMO = 3.50151768333134
  mo_energy =
[-0.86324393  3.50151768 18.57902962]
E1 = -3.8215989726275437  E_coul = 1.0475555597456476
Extra cycle  E= -2.7740434128819  delta_E= -4.44e-16  |g|= 9.96e-11  |ddm|= 7.51e-10
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 25.180015536905803
E1 = -3.8215989726275437  E_coul = 1.0475555597456476
init E= -2.7740434128819
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  HOMO = -0.863243926568128  LUMO = 3.50151768347536
  mo_energy =
[-0.86324393  3.50151768 18.57902962]
E1 = -3.821598972641062  E_coul = 1.0475555597591655
cycle= 1 E= -2.7740434128819  delta_E= -4.44e-16  |g|= 6.5e-12  |ddm|= 4.94e-11
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -3.821598972641062  E_coul = 1.0475555597591655
  HOMO = -0.863243926561366  LUMO = 3.50151768348457
  mo_energy =
[-0.86324393  3.50151768 18.57902962]
E1 = -3.821598972641924  E_coul = 1.0475555597600288
Extra cycle  E= -2.7740434128819  delta_E= 8.88e-16  |g|= 4.25e-13  |ddm|= 3.24e-12
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
exp = [8.46998865 3.58511518 0.55359356]
grad_E = [-0.00598465  0.02365492  0.03069003]
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:19 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  11.9920817459        1
[INPUT] 0    0    [1    /1   ]  3.67129857069        1
[INPUT] 0    0    [1    /1   ]  0.565927182659       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [11.992081745947747, 1.0]], [0, [3.671298570690943, 1.0]], [0, [0.5659271826593166, 1.0]]]}
ecp = {}
CPU time:        31.86
Set gradient conv threshold to 3.16228e-05
cond(S) = 13.778297715148657
E1 = -3.7887122595091394  E_coul = 1.0263971126812104
init E= -2.76231514682793
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.881418592914106  LUMO = 3.64643474222398
  mo_energy =
[-0.88141859  3.64643474 22.77830726]
E1 = -3.8491669618683764  E_coul = 1.0602046505225098
cycle= 1 E= -2.78896231134587  delta_E= -0.0266  |g|= 0.00859  |ddm|= 0.0203
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.864382887135377  LUMO = 3.67833980532919
  mo_energy =
[-0.86438289  3.67833981 22.82395693]
E1 = -3.848018120867942  E_coul = 1.0590471953971057
cycle= 2 E= -2.78897092547084  delta_E= -8.61e-06  |g|= 0.000534  |ddm|= 0.00368
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.864997889642803  LUMO = 3.67745638363308
  mo_energy =
[-0.86499789  3.67745638 22.82138436]
E1 = -3.8479424061549943  E_coul = 1.058971447618464
cycle= 3 E= -2.78897095853653  delta_E= -3.31e-08  |g|= 3.74e-06  |ddm|= 0.000247
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.864999888611974  LUMO = 3.67745325774163
  mo_energy =
[-0.86499989  3.67745326 22.82137652]
E1 = -3.8479421346254328  E_coul = 1.0589711760882405
cycle= 4 E= -2.78897095853719  delta_E= -6.62e-13  |g|= 8.61e-10  |ddm|= 1.17e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.8479421346254328  E_coul = 1.0589711760882405
  HOMO = -0.864999891224475  LUMO = 3.67745325980246
  mo_energy =
[-0.86499989  3.67745326 22.82137652]
E1 = -3.8479421347410425  E_coul = 1.0589711762038512
Extra cycle  E= -2.78897095853719  delta_E= 8.88e-16  |g|= 5.39e-11  |ddm|= 3.73e-10
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
exp = [11.99208175  3.67129857  0.56592718]
E = -2.7889709585371913
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:19 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  11.9920817459        1
[INPUT] 0    0    [1    /1   ]  3.67129857069        1
[INPUT] 0    0    [1    /1   ]  0.565927182659       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [11.992081745947747, 1.0]], [0, [3.671298570690943, 1.0]], [0, [0.5659271826593166, 1.0]]]}
ecp = {}
CPU time:        32.14
Set gradient conv threshold to 3.16228e-05
cond(S) = 13.778297715148657
E1 = -3.7887122595091394  E_coul = 1.0263971126812104
init E= -2.76231514682793
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.881418592914106  LUMO = 3.64643474222398
  mo_energy =
[-0.88141859  3.64643474 22.77830726]
E1 = -3.8491669618683764  E_coul = 1.0602046505225098
cycle= 1 E= -2.78896231134587  delta_E= -0.0266  |g|= 0.00859  |ddm|= 0.0203
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.864382887135377  LUMO = 3.67833980532919
  mo_energy =
[-0.86438289  3.67833981 22.82395693]
E1 = -3.848018120867942  E_coul = 1.0590471953971057
cycle= 2 E= -2.78897092547084  delta_E= -8.61e-06  |g|= 0.000534  |ddm|= 0.00368
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.864997889642803  LUMO = 3.67745638363308
  mo_energy =
[-0.86499789  3.67745638 22.82138436]
E1 = -3.8479424061549943  E_coul = 1.058971447618464
cycle= 3 E= -2.78897095853653  delta_E= -3.31e-08  |g|= 3.74e-06  |ddm|= 0.000247
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.864999888611974  LUMO = 3.67745325774163
  mo_energy =
[-0.86499989  3.67745326 22.82137652]
E1 = -3.8479421346254328  E_coul = 1.0589711760882405
cycle= 4 E= -2.78897095853719  delta_E= -6.62e-13  |g|= 8.61e-10  |ddm|= 1.17e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.8479421346254328  E_coul = 1.0589711760882405
  HOMO = -0.864999891224475  LUMO = 3.67745325980246
  mo_energy =
[-0.86499989  3.67745326 22.82137652]
E1 = -3.8479421347410425  E_coul = 1.0589711762038512
Extra cycle  E= -2.78897095853719  delta_E= 8.88e-16  |g|= 5.39e-11  |ddm|= 3.73e-10
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 13.778297715148657
E1 = -3.8479421347410425  E_coul = 1.0589711762038512
init E= -2.78897095853719
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  HOMO = -0.864999891166667  LUMO = 3.6774532598858
  mo_energy =
[-0.86499989  3.67745326 22.82137652]
E1 = -3.8479421347481866  E_coul = 1.0589711762109968
cycle= 1 E= -2.78897095853719  delta_E= 1.33e-15  |g|= 3.39e-12  |ddm|= 2.35e-11
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -3.8479421347481866  E_coul = 1.0589711762109968
  HOMO = -0.864999891163098  LUMO = 3.67745325989096
  mo_energy =
[-0.86499989  3.67745326 22.82137652]
E1 = -3.847942134748633  E_coul = 1.0589711762114418
Extra cycle  E= -2.78897095853719  delta_E= -8.88e-16  |g|= 2.15e-13  |ddm|= 1.48e-12
    CPU time for scf_cycle      0.08 sec, wall time      0.08 sec
exp = [11.99208175  3.67129857  0.56592718]
grad_E = [-0.00407703  0.0265639   0.05861742]
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:22 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  18.6624538795        1
[INPUT] 0    0    [1    /1   ]  3.37008935856        1
[INPUT] 0    0    [1    /1   ]  0.547988422553       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [18.66245387945761, 1.0]], [0, [3.3700893585601124, 1.0]], [0, [0.5479884225531559, 1.0]]]}
ecp = {}
CPU time:        34.38
Set gradient conv threshold to 3.16228e-05
cond(S) = 7.781346326429914
E1 = -3.8172760446105376  E_coul = 1.0277411996105297
init E= -2.78953484500001
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.893632394907914  LUMO = 3.36792944153708
  mo_energy =
[-0.89363239  3.36792944 29.0751623 ]
E1 = -3.88303918817116  E_coul = 1.0683180188494636
cycle= 1 E= -2.8147211693217  delta_E= -0.0252  |g|= 0.00785  |ddm|= 0.0407
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.873202517830204  LUMO = 3.40346431625435
  mo_energy =
[-0.87320252  3.40346432 29.14078805]
E1 = -3.8826028040781804  E_coul = 1.0678796616303328
cycle= 2 E= -2.81472314244785  delta_E= -1.97e-06  |g|= 0.000293  |ddm|= 0.0011
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.873430778320658  LUMO = 3.40315582937827
  mo_energy =
[-0.87343078  3.40315583 29.13963541]
E1 = -3.882576061411571  E_coul = 1.0678529142659086
cycle= 3 E= -2.81472314714566  delta_E= -4.7e-09  |g|= 4.67e-06  |ddm|= 7.17e-05
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.873435415687644  LUMO = 3.40314934493602
  mo_energy =
[-0.87343542  3.40314934 29.1396144 ]
E1 = -3.8825754620248714  E_coul = 1.0678523148772268
cycle= 4 E= -2.81472314714764  delta_E= -1.98e-12  |g|= 2.56e-10  |ddm|= 1.92e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.8825754620248714  E_coul = 1.0678523148772268
  HOMO = -0.87343541613521  LUMO = 3.4031493449692
  mo_energy =
[-0.87343542  3.40314934 29.1396144 ]
E1 = -3.882575462061214  E_coul = 1.0678523149135684
Extra cycle  E= -2.81472314714765  delta_E= -8.88e-16  |g|= 1.55e-11  |ddm|= 1.07e-10
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
exp = [18.66245388  3.37008936  0.54798842]
E = -2.8147231471476455
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:22 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  18.6624538795        1
[INPUT] 0    0    [1    /1   ]  3.37008935856        1
[INPUT] 0    0    [1    /1   ]  0.547988422553       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [18.66245387945761, 1.0]], [0, [3.3700893585601124, 1.0]], [0, [0.5479884225531559, 1.0]]]}
ecp = {}
CPU time:        34.68
Set gradient conv threshold to 3.16228e-05
cond(S) = 7.781346326429914
E1 = -3.8172760446105376  E_coul = 1.0277411996105297
init E= -2.78953484500001
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.893632394907914  LUMO = 3.36792944153708
  mo_energy =
[-0.89363239  3.36792944 29.0751623 ]
E1 = -3.88303918817116  E_coul = 1.0683180188494636
cycle= 1 E= -2.8147211693217  delta_E= -0.0252  |g|= 0.00785  |ddm|= 0.0407
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.873202517830204  LUMO = 3.40346431625435
  mo_energy =
[-0.87320252  3.40346432 29.14078805]
E1 = -3.8826028040781804  E_coul = 1.0678796616303328
cycle= 2 E= -2.81472314244785  delta_E= -1.97e-06  |g|= 0.000293  |ddm|= 0.0011
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.873430778320658  LUMO = 3.40315582937827
  mo_energy =
[-0.87343078  3.40315583 29.13963541]
E1 = -3.882576061411571  E_coul = 1.0678529142659086
cycle= 3 E= -2.81472314714566  delta_E= -4.7e-09  |g|= 4.67e-06  |ddm|= 7.17e-05
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.873435415687644  LUMO = 3.40314934493602
  mo_energy =
[-0.87343542  3.40314934 29.1396144 ]
E1 = -3.8825754620248714  E_coul = 1.0678523148772268
cycle= 4 E= -2.81472314714764  delta_E= -1.98e-12  |g|= 2.56e-10  |ddm|= 1.92e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.8825754620248714  E_coul = 1.0678523148772268
  HOMO = -0.87343541613521  LUMO = 3.4031493449692
  mo_energy =
[-0.87343542  3.40314934 29.1396144 ]
E1 = -3.882575462061214  E_coul = 1.0678523149135684
Extra cycle  E= -2.81472314714765  delta_E= -8.88e-16  |g|= 1.55e-11  |ddm|= 1.07e-10
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 7.781346326429914
E1 = -3.882575462061214  E_coul = 1.0678523149135684
init E= -2.81472314714765
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  HOMO = -0.873435416117039  LUMO = 3.4031493449943
  mo_energy =
[-0.87343542  3.40314934 29.1396144 ]
E1 = -3.8825754620634823  E_coul = 1.0678523149158365
cycle= 1 E= -2.81472314714765  delta_E= -4.44e-16  |g|= 9.94e-13  |ddm|= 6.82e-12
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -3.8825754620634823  E_coul = 1.0678523149158365
  HOMO = -0.873435416115904  LUMO = 3.40314934499586
  mo_energy =
[-0.87343542  3.40314934 29.1396144 ]
E1 = -3.882575462063624  E_coul = 1.067852314915979
Extra cycle  E= -2.81472314714765  delta_E= 8.88e-16  |g|= 6.62e-14  |ddm|= 4.36e-13
    CPU time for scf_cycle      0.08 sec, wall time      0.08 sec
exp = [18.66245388  3.37008936  0.54798842]
grad_E = [-0.00118907  0.01776976  0.10844202]
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:24 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  23.4329741805        1
[INPUT] 0    0    [1    /1   ]  2.83857602276        1
[INPUT] 0    0    [1    /1   ]  0.483322267313       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [23.432974180497354, 1.0]], [0, [2.838576022764637, 1.0]], [0, [0.48332226731318856, 1.0]]]}
ecp = {}
CPU time:        36.97
Set gradient conv threshold to 3.16228e-05
cond(S) = 6.130386721800235
E1 = -3.8352770415760036  E_coul = 1.0259999073017079
init E= -2.8092771342743
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.900691798311548  LUMO = 2.74036155704356
  mo_energy =
[-0.9006918   2.74036156 32.36390579]
E1 = -3.8800435220437497  E_coul = 1.0526817747076405
cycle= 1 E= -2.82736174733611  delta_E= -0.0181  |g|= 0.0151  |ddm|= 0.0421
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.887341709592791  LUMO = 2.76184456528091
  mo_energy =
[-0.88734171  2.76184457 32.40561779]
E1 = -3.8799248168940963  E_coul = 1.052559511597091
cycle= 2 E= -2.82736530529701  delta_E= -3.56e-06  |g|= 0.000489  |ddm|= 0.000663
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.887404937290771  LUMO = 2.76177816938832
  mo_energy =
[-0.88740494  2.76177817 32.40512418]
E1 = -3.879922112651319  E_coul = 1.0525568036221886
cycle= 3 E= -2.82736530902913  delta_E= -3.73e-09  |g|= 5.97e-07  |ddm|= 2.32e-05
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.887404203041512  LUMO = 2.76177905821888
  mo_energy =
[-0.8874042   2.76177906 32.40512762]
E1 = -3.879922211378761  E_coul = 1.0525569023495869
cycle= 4 E= -2.82736530902917  delta_E= -4.35e-14  |g|= 3.57e-10  |ddm|= 2.96e-07
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.879922211378761  E_coul = 1.0525569023495869
  HOMO = -0.887404203339795  LUMO = 2.76177905799054
  mo_energy =
[-0.8874042   2.76177906 32.40512762]
E1 = -3.879922211434887  E_coul = 1.0525569024057124
Extra cycle  E= -2.82736530902917  delta_E= -4.44e-16  |g|= 2.15e-11  |ddm|= 1.59e-10
    CPU time for scf_cycle      0.07 sec, wall time      0.08 sec
exp = [23.43297418  2.83857602  0.48332227]
E = -2.8273653090291746
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:25 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  23.4329741805        1
[INPUT] 0    0    [1    /1   ]  2.83857602276        1
[INPUT] 0    0    [1    /1   ]  0.483322267313       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [23.432974180497354, 1.0]], [0, [2.838576022764637, 1.0]], [0, [0.48332226731318856, 1.0]]]}
ecp = {}
CPU time:        37.30
Set gradient conv threshold to 3.16228e-05
cond(S) = 6.130386721800235
E1 = -3.8352770415760036  E_coul = 1.0259999073017079
init E= -2.8092771342743
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.900691798311548  LUMO = 2.74036155704356
  mo_energy =
[-0.9006918   2.74036156 32.36390579]
E1 = -3.8800435220437497  E_coul = 1.0526817747076405
cycle= 1 E= -2.82736174733611  delta_E= -0.0181  |g|= 0.0151  |ddm|= 0.0421
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.887341709592791  LUMO = 2.76184456528091
  mo_energy =
[-0.88734171  2.76184457 32.40561779]
E1 = -3.8799248168940963  E_coul = 1.052559511597091
cycle= 2 E= -2.82736530529701  delta_E= -3.56e-06  |g|= 0.000489  |ddm|= 0.000663
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.887404937290771  LUMO = 2.76177816938832
  mo_energy =
[-0.88740494  2.76177817 32.40512418]
E1 = -3.879922112651319  E_coul = 1.0525568036221886
cycle= 3 E= -2.82736530902913  delta_E= -3.73e-09  |g|= 5.97e-07  |ddm|= 2.32e-05
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.887404203041512  LUMO = 2.76177905821888
  mo_energy =
[-0.8874042   2.76177906 32.40512762]
E1 = -3.879922211378761  E_coul = 1.0525569023495869
cycle= 4 E= -2.82736530902917  delta_E= -4.35e-14  |g|= 3.57e-10  |ddm|= 2.96e-07
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.879922211378761  E_coul = 1.0525569023495869
  HOMO = -0.887404203339795  LUMO = 2.76177905799054
  mo_energy =
[-0.8874042   2.76177906 32.40512762]
E1 = -3.879922211434887  E_coul = 1.0525569024057124
Extra cycle  E= -2.82736530902917  delta_E= -4.44e-16  |g|= 2.15e-11  |ddm|= 1.59e-10
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 6.130386721800235
E1 = -3.879922211434887  E_coul = 1.0525569024057124
init E= -2.82736530902917
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  HOMO = -0.887404203311731  LUMO = 2.76177905802438
  mo_energy =
[-0.8874042   2.76177906 32.40512762]
E1 = -3.8799222114385983  E_coul = 1.052556902409424
cycle= 1 E= -2.82736530902917  delta_E= 4.44e-16  |g|= 1.49e-12  |ddm|= 1.08e-11
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -3.8799222114385983  E_coul = 1.052556902409424
  HOMO = -0.887404203309874  LUMO = 2.76177905802663
  mo_energy =
[-0.8874042   2.76177906 32.40512762]
E1 = -3.8799222114388443  E_coul = 1.0525569024096715
Extra cycle  E= -2.82736530902917  delta_E= 1.33e-15  |g|= 1.03e-13  |ddm|= 7.36e-13
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
exp = [23.43297418  2.83857602  0.48332227]
grad_E = [ 0.00064583 -0.00062613  0.08499709]
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:27 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  23.1762478141        1
[INPUT] 0    0    [1    /1   ]  2.74066541353        1
[INPUT] 0    0    [1    /1   ]  0.451221043727       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [23.176247814060797, 1.0]], [0, [2.7406654135336765, 1.0]], [0, [0.4512210437272517, 1.0]]]}
ecp = {}
CPU time:        39.57
Set gradient conv threshold to 3.16228e-05
cond(S) = 5.884908548349708
E1 = -3.841188643154547  E_coul = 1.0243740612417593
init E= -2.81681458191279
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.902364221816972  LUMO = 2.5591314711383
  mo_energy =
[-0.90236422  2.55913147 31.65202894]
E1 = -3.867014759892389  E_coul = 1.0379218525630007
cycle= 1 E= -2.82909290732939  delta_E= -0.0123  |g|= 0.0095  |ddm|= 0.0166
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.895586793723051  LUMO = 2.57101631270716
  mo_energy =
[-0.89558679  2.57101631 31.66849879]
E1 = -3.866456233696073  E_coul = 1.0373606827006867
cycle= 2 E= -2.82909555099539  delta_E= -2.64e-06  |g|= 0.000304  |ddm|= 0.00139
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.895877034949568  LUMO = 2.57068039807788
  mo_energy =
[-0.89587703  2.5706804  31.66700376]
E1 = -3.866422060284096  E_coul = 1.0373265034148182
cycle= 3 E= -2.82909555686928  delta_E= -5.87e-09  |g|= 6.5e-06  |ddm|= 9.06e-05
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.895885067115025  LUMO = 2.57067087530491
  mo_energy =
[-0.89588507  2.57067088 31.66696627]
E1 = -3.866420978352939  E_coul = 1.0373254214786511
cycle= 4 E= -2.82909555687429  delta_E= -5.01e-12  |g|= 2.51e-10  |ddm|= 3.2e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.866420978352939  E_coul = 1.0373254214786511
  HOMO = -0.895885067697821  LUMO = 2.57067087539502
  mo_energy =
[-0.89588507  2.57067088 31.66696627]
E1 = -3.8664209783965955  E_coul = 1.0373254215223078
Extra cycle  E= -2.82909555687429  delta_E=    0  |g|= 1.57e-11  |ddm|= 1.22e-10
    CPU time for scf_cycle      0.06 sec, wall time      0.06 sec
exp = [23.17624781  2.74066541  0.45122104]
E = -2.8290955568742877
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:27 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  23.1762478141        1
[INPUT] 0    0    [1    /1   ]  2.74066541353        1
[INPUT] 0    0    [1    /1   ]  0.451221043727       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [23.176247814060797, 1.0]], [0, [2.7406654135336765, 1.0]], [0, [0.4512210437272517, 1.0]]]}
ecp = {}
CPU time:        39.90
Set gradient conv threshold to 3.16228e-05
cond(S) = 5.884908548349708
E1 = -3.841188643154547  E_coul = 1.0243740612417593
init E= -2.81681458191279
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.902364221816972  LUMO = 2.5591314711383
  mo_energy =
[-0.90236422  2.55913147 31.65202894]
E1 = -3.867014759892389  E_coul = 1.0379218525630007
cycle= 1 E= -2.82909290732939  delta_E= -0.0123  |g|= 0.0095  |ddm|= 0.0166
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.895586793723051  LUMO = 2.57101631270716
  mo_energy =
[-0.89558679  2.57101631 31.66849879]
E1 = -3.866456233696073  E_coul = 1.0373606827006867
cycle= 2 E= -2.82909555099539  delta_E= -2.64e-06  |g|= 0.000304  |ddm|= 0.00139
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.895877034949568  LUMO = 2.57068039807788
  mo_energy =
[-0.89587703  2.5706804  31.66700376]
E1 = -3.866422060284096  E_coul = 1.0373265034148182
cycle= 3 E= -2.82909555686928  delta_E= -5.87e-09  |g|= 6.5e-06  |ddm|= 9.06e-05
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.895885067115025  LUMO = 2.57067087530491
  mo_energy =
[-0.89588507  2.57067088 31.66696627]
E1 = -3.866420978352939  E_coul = 1.0373254214786511
cycle= 4 E= -2.82909555687429  delta_E= -5.01e-12  |g|= 2.51e-10  |ddm|= 3.2e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.866420978352939  E_coul = 1.0373254214786511
  HOMO = -0.895885067697821  LUMO = 2.57067087539502
  mo_energy =
[-0.89588507  2.57067088 31.66696627]
E1 = -3.8664209783965955  E_coul = 1.0373254215223078
Extra cycle  E= -2.82909555687429  delta_E=    0  |g|= 1.57e-11  |ddm|= 1.22e-10
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 5.884908548349708
E1 = -3.8664209783965955  E_coul = 1.0373254215223078
init E= -2.82909555687429
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  HOMO = -0.895885067675989  LUMO = 2.57067087542071
  mo_energy =
[-0.89588507  2.57067088 31.66696627]
E1 = -3.86642097839943  E_coul = 1.0373254215251437
cycle= 1 E= -2.82909555687429  delta_E= 1.33e-15  |g|= 1.09e-12  |ddm|= 8.15e-12
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -3.86642097839943  E_coul = 1.0373254215251437
  HOMO = -0.895885067674572  LUMO = 2.57067087542239
  mo_energy =
[-0.89588507  2.57067088 31.66696627]
E1 = -3.86642097839962  E_coul = 1.0373254215253322
Extra cycle  E= -2.82909555687429  delta_E= -1.33e-15  |g|= 7.03e-14  |ddm|= 5.45e-13
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
exp = [23.17624781  2.74066541  0.45122104]
grad_E = [ 0.0006754   0.00545597 -0.00367483]
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:30 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  21.6608441202        1
[INPUT] 0    0    [1    /1   ]  2.58458023915        1
[INPUT] 0    0    [1    /1   ]  0.4333600661         1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [21.660844120169173, 1.0]], [0, [2.5845802391504065, 1.0]], [0, [0.4333600660996036, 1.0]]]}
ecp = {}
CPU time:        42.13
Set gradient conv threshold to 3.16228e-05
cond(S) = 6.0027994231125685
E1 = -3.844123350897567  E_coul = 1.0238995460191878
init E= -2.82022380487838
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.903412265027488  LUMO = 2.39372435141233
  mo_energy =
[-0.90341227  2.39372435 29.41148159]
E1 = -3.8644835325971494  E_coul = 1.03374875674546
cycle= 1 E= -2.83073477585169  delta_E= -0.0105  |g|= 0.00931  |ddm|= 0.0149
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.898494271459352  LUMO = 2.40267787542339
  mo_energy =
[-0.89849427  2.40267788 29.42121067]
E1 = -3.8639191634037746  E_coul = 1.0331817538196506
cycle= 2 E= -2.83073740958412  delta_E= -2.63e-06  |g|= 0.000302  |ddm|= 0.00138
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.898787689624685  LUMO = 2.40235535499756
  mo_energy =
[-0.89878769  2.40235535 29.4197409 ]
E1 = -3.8638847745107627  E_coul = 1.0331473591793097
cycle= 3 E= -2.83073741533145  delta_E= -5.75e-09  |g|= 6.32e-06  |ddm|= 8.99e-05
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.898795569227646  LUMO = 2.40234645902435
  mo_energy =
[-0.89879557  2.40234646 29.4197052 ]
E1 = -3.863883690964877  E_coul = 1.0331462756286083
cycle= 4 E= -2.83073741533627  delta_E= -4.82e-12  |g|= 2.66e-10  |ddm|= 3.2e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.863883690964877  E_coul = 1.0331462756286083
  HOMO = -0.89879556985383  LUMO = 2.40234645912176
  mo_energy =
[-0.89879557  2.40234646 29.41970519]
E1 = -3.8638836910129575  E_coul = 1.0331462756766892
Extra cycle  E= -2.83073741533627  delta_E=    0  |g|= 1.67e-11  |ddm|= 1.34e-10
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
exp = [21.66084412  2.58458024  0.43336007]
E = -2.8307374153362685
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:30 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  21.6608441202        1
[INPUT] 0    0    [1    /1   ]  2.58458023915        1
[INPUT] 0    0    [1    /1   ]  0.4333600661         1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [21.660844120169173, 1.0]], [0, [2.5845802391504065, 1.0]], [0, [0.4333600660996036, 1.0]]]}
ecp = {}
CPU time:        42.49
Set gradient conv threshold to 3.16228e-05
cond(S) = 6.0027994231125685
E1 = -3.844123350897567  E_coul = 1.0238995460191878
init E= -2.82022380487838
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.903412265027488  LUMO = 2.39372435141233
  mo_energy =
[-0.90341227  2.39372435 29.41148159]
E1 = -3.8644835325971494  E_coul = 1.03374875674546
cycle= 1 E= -2.83073477585169  delta_E= -0.0105  |g|= 0.00931  |ddm|= 0.0149
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.898494271459352  LUMO = 2.40267787542339
  mo_energy =
[-0.89849427  2.40267788 29.42121067]
E1 = -3.8639191634037746  E_coul = 1.0331817538196506
cycle= 2 E= -2.83073740958412  delta_E= -2.63e-06  |g|= 0.000302  |ddm|= 0.00138
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.898787689624685  LUMO = 2.40235535499756
  mo_energy =
[-0.89878769  2.40235535 29.4197409 ]
E1 = -3.8638847745107627  E_coul = 1.0331473591793097
cycle= 3 E= -2.83073741533145  delta_E= -5.75e-09  |g|= 6.32e-06  |ddm|= 8.99e-05
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.898795569227646  LUMO = 2.40234645902435
  mo_energy =
[-0.89879557  2.40234646 29.4197052 ]
E1 = -3.863883690964877  E_coul = 1.0331462756286083
cycle= 4 E= -2.83073741533627  delta_E= -4.82e-12  |g|= 2.66e-10  |ddm|= 3.2e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.863883690964877  E_coul = 1.0331462756286083
  HOMO = -0.89879556985383  LUMO = 2.40234645912176
  mo_energy =
[-0.89879557  2.40234646 29.41970519]
E1 = -3.8638836910129575  E_coul = 1.0331462756766892
Extra cycle  E= -2.83073741533627  delta_E=    0  |g|= 1.67e-11  |ddm|= 1.34e-10
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 6.0027994231125685
E1 = -3.8638836910129575  E_coul = 1.0331462756766892
init E= -2.83073741533627
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  HOMO = -0.898795569829791  LUMO = 2.40234645914869
  mo_energy =
[-0.89879557  2.40234646 29.41970519]
E1 = -3.8638836910161243  E_coul = 1.0331462756798562
cycle= 1 E= -2.83073741533627  delta_E= 4.44e-16  |g|= 1.19e-12  |ddm|= 9.06e-12
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -3.8638836910161243  E_coul = 1.0331462756798562
  HOMO = -0.898795569828207  LUMO = 2.40234645915046
  mo_energy =
[-0.89879557  2.40234646 29.41970519]
E1 = -3.8638836910163383  E_coul = 1.0331462756800696
Extra cycle  E= -2.83073741533627  delta_E= -4.44e-16  |g|= 8.38e-14  |ddm|= 6.19e-13
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
exp = [21.66084412  2.58458024  0.43336007]
grad_E = [ 0.00076939  0.0039905  -0.0176757 ]
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:32 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  8.28162962308        1
[INPUT] 0    0    [1    /1   ]  1.70871535505        1
[INPUT] 0    0    [1    /1   ]  0.345137291778       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [8.281629623082376, 1.0]], [0, [1.7087153550457672, 1.0]], [0, [0.3451372917784925, 1.0]]]}
ecp = {}
CPU time:        44.80
Set gradient conv threshold to 3.16228e-05
cond(S) = 10.506659150130906
E1 = -3.8440595696531097  E_coul = 1.0231869605021842
init E= -2.82087260915093
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.90080559916345  LUMO = 1.59301446531262
  mo_energy =
[-0.9008056   1.59301447 12.4845218 ]
E1 = -3.8407947513154537  E_coul = 1.0159390860012611
cycle= 1 E= -2.82485566531419  delta_E= -0.00398  |g|= 0.00611  |ddm|= 0.0358
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.904461067929744  LUMO = 1.59154924850707
  mo_energy =
[-0.90446107  1.59154925 12.47198282]
E1 = -3.839583388476624  E_coul = 1.0147216821932794
cycle= 2 E= -2.82486170628334  delta_E= -6.04e-06  |g|= 0.000607  |ddm|= 0.00391
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.905124307460331  LUMO = 1.59101666112096
  mo_energy =
[-0.90512431  1.59101666 12.46992163]
E1 = -3.8394745360324674  E_coul = 1.0146127825916393
cycle= 3 E= -2.82486175344083  delta_E= -4.72e-08  |g|= 1.07e-05  |ddm|= 0.000373
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.90512472409283  LUMO = 1.59101572805299
  mo_energy =
[-0.90512472  1.59101573 12.4699216 ]
E1 = -3.8394740537362826  E_coul = 1.0146123002899423
cycle= 4 E= -2.82486175344634  delta_E= -5.51e-12  |g|= 1.29e-09  |ddm|= 3.12e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.8394740537362826  E_coul = 1.0146123002899423
  HOMO = -0.905124726578199  LUMO = 1.59101573225617
  mo_energy =
[-0.90512473  1.59101573 12.46992161]
E1 = -3.839474053425069  E_coul = 1.01461229997873
Extra cycle  E= -2.82486175344634  delta_E= 1.33e-15  |g|= 9.71e-11  |ddm|= 8.34e-10
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
exp = [8.28162962 1.70871536 0.34513729]
E = -2.824861753446339
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:33 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  17.142196348         1
[INPUT] 0    0    [1    /1   ]  2.28876878414        1
[INPUT] 0    0    [1    /1   ]  0.403564023684       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [17.142196348040265, 1.0]], [0, [2.288768784142556, 1.0]], [0, [0.4035640236844138, 1.0]]]}
ecp = {}
CPU time:        45.16
Set gradient conv threshold to 3.16228e-05
cond(S) = 6.678118012839682
E1 = -3.8503634990213413  E_coul = 1.023599923015193
init E= -2.82676357600615
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.905324622208659  LUMO = 2.1072066236596
  mo_energy =
[-0.90532462  2.10720662 23.47377845]
E1 = -3.8629365757911223  E_coul = 1.0286708764064492
cycle= 1 E= -2.83426569938467  delta_E= -0.0075  |g|= 0.0071  |ddm|= 0.012
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.902798390185903  LUMO = 2.11245446529133
  mo_energy =
[-0.90279839  2.11245447 23.47648584]
E1 = -3.862382376199032  E_coul = 1.0281146287757315
cycle= 2 E= -2.8342677474233  delta_E= -2.05e-06  |g|= 0.000249  |ddm|= 0.00132
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.903087063473672  LUMO = 2.11216925692106
  mo_energy =
[-0.90308706  2.11216926 23.4751785 ]
E1 = -3.8623483179248015  E_coul = 1.0280805655550755
cycle= 3 E= -2.83426775236973  delta_E= -4.95e-09  |g|= 5.85e-06  |ddm|= 8.73e-05
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.903094102364845  LUMO = 2.11216206553277
  mo_energy =
[-0.9030941   2.11216207 23.47514938]
E1 = -3.8623472987268426  E_coul = 1.0280795463530643
cycle= 4 E= -2.83426775237378  delta_E= -4.05e-12  |g|= 2.44e-10  |ddm|= 3.07e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.8623472987268426  E_coul = 1.0280795463530643
  HOMO = -0.903094103010357  LUMO = 2.11216206570449
  mo_energy =
[-0.9030941   2.11216207 23.47514938]
E1 = -3.8623472987737277  E_coul = 1.0280795463999495
Extra cycle  E= -2.83426775237378  delta_E=    0  |g|= 1.53e-11  |ddm|= 1.28e-10
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
exp = [17.14219635  2.28876878  0.40356402]
E = -2.834267752373778
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:33 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  17.142196348         1
[INPUT] 0    0    [1    /1   ]  2.28876878414        1
[INPUT] 0    0    [1    /1   ]  0.403564023684       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [17.142196348040265, 1.0]], [0, [2.288768784142556, 1.0]], [0, [0.4035640236844138, 1.0]]]}
ecp = {}
CPU time:        45.52
Set gradient conv threshold to 3.16228e-05
cond(S) = 6.678118012839682
E1 = -3.8503634990213413  E_coul = 1.023599923015193
init E= -2.82676357600615
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.905324622208659  LUMO = 2.1072066236596
  mo_energy =
[-0.90532462  2.10720662 23.47377845]
E1 = -3.8629365757911223  E_coul = 1.0286708764064492
cycle= 1 E= -2.83426569938467  delta_E= -0.0075  |g|= 0.0071  |ddm|= 0.012
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.902798390185903  LUMO = 2.11245446529133
  mo_energy =
[-0.90279839  2.11245447 23.47648584]
E1 = -3.862382376199032  E_coul = 1.0281146287757315
cycle= 2 E= -2.8342677474233  delta_E= -2.05e-06  |g|= 0.000249  |ddm|= 0.00132
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.903087063473672  LUMO = 2.11216925692106
  mo_energy =
[-0.90308706  2.11216926 23.4751785 ]
E1 = -3.8623483179248015  E_coul = 1.0280805655550755
cycle= 3 E= -2.83426775236973  delta_E= -4.95e-09  |g|= 5.85e-06  |ddm|= 8.73e-05
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.903094102364845  LUMO = 2.11216206553277
  mo_energy =
[-0.9030941   2.11216207 23.47514938]
E1 = -3.8623472987268426  E_coul = 1.0280795463530643
cycle= 4 E= -2.83426775237378  delta_E= -4.05e-12  |g|= 2.44e-10  |ddm|= 3.07e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.8623472987268426  E_coul = 1.0280795463530643
  HOMO = -0.903094103010357  LUMO = 2.11216206570449
  mo_energy =
[-0.9030941   2.11216207 23.47514938]
E1 = -3.8623472987737277  E_coul = 1.0280795463999495
Extra cycle  E= -2.83426775237378  delta_E=    0  |g|= 1.53e-11  |ddm|= 1.28e-10
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 6.678118012839682
E1 = -3.8623472987737277  E_coul = 1.0280795463999495
init E= -2.83426775237378
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  HOMO = -0.903094102986916  LUMO = 2.11216206572813
  mo_energy =
[-0.9030941   2.11216207 23.47514938]
E1 = -3.8623472987768888  E_coul = 1.028079546403111
cycle= 1 E= -2.83426775237378  delta_E=    0  |g|= 1.18e-12  |ddm|= 9.02e-12
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -3.8623472987768888  E_coul = 1.028079546403111
  HOMO = -0.903094102985336  LUMO = 2.11216206572973
  mo_energy =
[-0.9030941   2.11216207 23.47514938]
E1 = -3.8623472987771104  E_coul = 1.0280795464033325
Extra cycle  E= -2.83426775237378  delta_E=    0  |g|= 8.39e-14  |ddm|= 6.48e-13
    CPU time for scf_cycle      0.08 sec, wall time      0.08 sec
exp = [17.14219635  2.28876878  0.40356402]
grad_E = [ 0.00046018  0.00544312 -0.03357913]
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:35 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  7.97979590038        1
[INPUT] 0    0    [1    /1   ]  1.60948817648        1
[INPUT] 0    0    [1    /1   ]  0.35058309983        1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [7.97979590038106, 1.0]], [0, [1.6094881764798554, 1.0]], [0, [0.35058309983012953, 1.0]]]}
ecp = {}
CPU time:        47.77
Set gradient conv threshold to 3.16228e-05
cond(S) = 11.06545984000079
E1 = -3.8452326969061783  E_coul = 1.023603005944519
init E= -2.82162969096166
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.900994594401146  LUMO = 1.55331836176953
  mo_energy =
[-0.90099459  1.55331836 11.91542384]
E1 = -3.847402408027025  E_coul = 1.0217874516640049
cycle= 1 E= -2.82561495636302  delta_E= -0.00399  |g|= 0.00469  |ddm|= 0.0132
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.90191454647951  LUMO = 1.55435809985974
  mo_energy =
[-0.90191455  1.5543581  11.91068006]
E1 = -3.8468151065071323  E_coul = 1.0211984779587981
cycle= 2 E= -2.82561662854833  delta_E= -1.67e-06  |g|= 0.000206  |ddm|= 0.00128
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.902223386597394  LUMO = 1.55413828792564
  mo_energy =
[-0.90222339  1.55413829 11.90969588]
E1 = -3.8467767380948366  E_coul = 1.0211601044829957
cycle= 3 E= -2.82561663361184  delta_E= -5.06e-09  |g|= 5.94e-06  |ddm|= 9.29e-05
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.902228758738941  LUMO = 1.55413409996811
  mo_energy =
[-0.90222876  1.5541341  11.90967969]
E1 = -3.8467757476304314  E_coul = 1.0211591140143872
cycle= 4 E= -2.82561663361604  delta_E= -4.2e-12  |g|= 3.2e-10  |ddm|= 3.65e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.02 sec
E1 = -3.8467757476304314  E_coul = 1.0211591140143872
  HOMO = -0.902228759800828  LUMO = 1.55413410043202
  mo_energy =
[-0.90222876  1.5541341  11.90967969]
E1 = -3.8467757476982354  E_coul = 1.0211591140821903
Extra cycle  E= -2.82561663361605  delta_E= -8.88e-16  |g|= 2e-11  |ddm|= 1.75e-10
    CPU time for scf_cycle      0.08 sec, wall time      0.08 sec
exp = [7.9797959  1.60948818 0.3505831 ]
E = -2.825616633616045
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:36 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  15.2414369696        1
[INPUT] 0    0    [1    /1   ]  2.1478505834         1
[INPUT] 0    0    [1    /1   ]  0.39257301882        1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [15.241436969601544, 1.0]], [0, [2.1478505833956882, 1.0]], [0, [0.3925730188195144, 1.0]]]}
ecp = {}
CPU time:        48.16
Set gradient conv threshold to 3.16228e-05
cond(S) = 7.124571312703486
E1 = -3.852300553726467  E_coul = 1.0236863489658181
init E= -2.82861420476065
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.905791202246778  LUMO = 1.98565436702821
  mo_energy =
[-0.9057912   1.98565437 20.98385536]
E1 = -3.863486468083677  E_coul = 1.0281979390565084
cycle= 1 E= -2.83528852902717  delta_E= -0.00667  |g|= 0.00723  |ddm|= 0.0124
    CPU time for cycle= 1      0.01 sec, wall time      0.03 sec
  HOMO = -0.903546170459128  LUMO = 1.99027401526529
  mo_energy =
[-0.90354617  1.99027402 20.98629101]
E1 = -3.863030974778282  E_coul = 1.0277406200499841
cycle= 2 E= -2.8352903547283  delta_E= -1.83e-06  |g|= 0.000265  |ddm|= 0.00102
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.903783945017917  LUMO = 1.99005471423731
  mo_energy =
[-0.90378395  1.99005471 20.98524129]
E1 = -3.8630048529815726  E_coul = 1.0277144946820866
cycle= 3 E= -2.83529035829949  delta_E= -3.57e-09  |g|= 3.64e-06  |ddm|= 6.22e-05
    CPU time for cycle= 3      0.01 sec, wall time      0.02 sec
  HOMO = -0.903788254667526  LUMO = 1.99005053834436
  mo_energy =
[-0.90378825  1.99005054 20.98522427]
E1 = -3.8630042061119316  E_coul = 1.0277138478108452
cycle= 4 E= -2.83529035830109  delta_E= -1.6e-12  |g|= 2.95e-10  |ddm|= 1.98e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.8630042061119316  E_coul = 1.0277138478108452
  HOMO = -0.903788255245123  LUMO = 1.99005053838642
  mo_energy =
[-0.90378826  1.99005054 20.98522427]
E1 = -3.863004206169821  E_coul = 1.0277138478687347
Extra cycle  E= -2.83529035830109  delta_E=    0  |g|= 1.85e-11  |ddm|= 1.56e-10
    CPU time for scf_cycle      0.08 sec, wall time      0.10 sec
exp = [15.24143697  2.14785058  0.39257302]
E = -2.8352903583010862
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:36 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  15.2414369696        1
[INPUT] 0    0    [1    /1   ]  2.1478505834         1
[INPUT] 0    0    [1    /1   ]  0.39257301882        1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [15.241436969601544, 1.0]], [0, [2.1478505833956882, 1.0]], [0, [0.3925730188195144, 1.0]]]}
ecp = {}
CPU time:        48.56
Set gradient conv threshold to 3.16228e-05
cond(S) = 7.124571312703486
E1 = -3.852300553726467  E_coul = 1.0236863489658181
init E= -2.82861420476065
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.905791202246778  LUMO = 1.98565436702821
  mo_energy =
[-0.9057912   1.98565437 20.98385536]
E1 = -3.863486468083677  E_coul = 1.0281979390565084
cycle= 1 E= -2.83528852902717  delta_E= -0.00667  |g|= 0.00723  |ddm|= 0.0124
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.903546170459128  LUMO = 1.99027401526529
  mo_energy =
[-0.90354617  1.99027402 20.98629101]
E1 = -3.863030974778282  E_coul = 1.0277406200499841
cycle= 2 E= -2.8352903547283  delta_E= -1.83e-06  |g|= 0.000265  |ddm|= 0.00102
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.903783945017917  LUMO = 1.99005471423731
  mo_energy =
[-0.90378395  1.99005471 20.98524129]
E1 = -3.8630048529815726  E_coul = 1.0277144946820866
cycle= 3 E= -2.83529035829949  delta_E= -3.57e-09  |g|= 3.64e-06  |ddm|= 6.22e-05
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.903788254667526  LUMO = 1.99005053834436
  mo_energy =
[-0.90378825  1.99005054 20.98522427]
E1 = -3.8630042061119316  E_coul = 1.0277138478108452
cycle= 4 E= -2.83529035830109  delta_E= -1.6e-12  |g|= 2.95e-10  |ddm|= 1.98e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.8630042061119316  E_coul = 1.0277138478108452
  HOMO = -0.903788255245123  LUMO = 1.99005053838642
  mo_energy =
[-0.90378826  1.99005054 20.98522427]
E1 = -3.863004206169821  E_coul = 1.0277138478687347
Extra cycle  E= -2.83529035830109  delta_E=    0  |g|= 1.85e-11  |ddm|= 1.56e-10
    CPU time for scf_cycle      0.08 sec, wall time      0.08 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 7.124571312703486
E1 = -3.863004206169821  E_coul = 1.0277138478687347
init E= -2.83529035830109
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  HOMO = -0.903788255216173  LUMO = 1.99005053841403
  mo_energy =
[-0.90378826  1.99005054 20.98522427]
E1 = -3.863004206173801  E_coul = 1.0277138478727146
cycle= 1 E= -2.83529035830109  delta_E=    0  |g|= 1.51e-12  |ddm|= 1.14e-11
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -3.863004206173801  E_coul = 1.0277138478727146
  HOMO = -0.903788255214187  LUMO = 1.99005053841594
  mo_energy =
[-0.90378826  1.99005054 20.98522427]
E1 = -3.863004206174093  E_coul = 1.0277138478730043
Extra cycle  E= -2.83529035830109  delta_E= -2.66e-15  |g|= 1.2e-13  |ddm|= 8.53e-13
    CPU time for scf_cycle      0.08 sec, wall time      0.08 sec
exp = [15.24143697  2.14785058  0.39257302]
grad_E = [ 0.00020041  0.0043352  -0.02385517]
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:39 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  12.8350434572        1
[INPUT] 0    0    [1    /1   ]  1.91733245239        1
[INPUT] 0    0    [1    /1   ]  0.377060832643       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [12.83504345720321, 1.0]], [0, [1.917332452391576, 1.0]], [0, [0.37706083264260676, 1.0]]]}
ecp = {}
CPU time:        50.84
Set gradient conv threshold to 3.16228e-05
cond(S) = 7.912389027176285
E1 = -3.8531262828449533  E_coul = 1.0237248461020676
init E= -2.82940143674289
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.90589440161424  LUMO = 1.79796704762584
  mo_energy =
[-0.9058944   1.79796705 17.7163767 ]
E1 = -3.8643794715709534  E_coul = 1.0288189665327034
cycle= 1 E= -2.83556050503825  delta_E= -0.00616  |g|= 0.0101  |ddm|= 0.021
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.903372145785336  LUMO = 1.80244084640363
  mo_energy =
[-0.90337215  1.80244085 17.72028791]
E1 = -3.8642435249339346  E_coul = 1.0286801396862402
cycle= 2 E= -2.83556338524769  delta_E= -2.88e-06  |g|= 0.000477  |ddm|= 0.000881
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.903444848079322  LUMO = 1.80239353498459
  mo_energy =
[-0.90344485  1.80239353 17.71988822]
E1 = -3.8642483590497854  E_coul = 1.0286849671369378
cycle= 3 E= -2.83556339191285  delta_E= -6.67e-09  |g|= 5.19e-06  |ddm|= 6.41e-05
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.903438721087131  LUMO = 1.80239891142498
  mo_energy =
[-0.90343872  1.80239891 17.71991071]
E1 = -3.8642493405383007  E_coul = 1.028685948621897
cycle= 4 E= -2.8355633919164  delta_E= -3.56e-12  |g|= 6.3e-10  |ddm|= 3.09e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.8642493405383007  E_coul = 1.028685948621897
  HOMO = -0.903438721647253  LUMO = 1.80239891113426
  mo_energy =
[-0.90343872  1.80239891 17.71991071]
E1 = -3.8642493406685015  E_coul = 1.0286859487520972
Extra cycle  E= -2.8355633919164  delta_E= -4.44e-16  |g|= 4.18e-11  |ddm|= 3.52e-10
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
exp = [12.83504346  1.91733245  0.37706083]
E = -2.8355633919164043
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:39 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  12.8350434572        1
[INPUT] 0    0    [1    /1   ]  1.91733245239        1
[INPUT] 0    0    [1    /1   ]  0.377060832643       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [12.83504345720321, 1.0]], [0, [1.917332452391576, 1.0]], [0, [0.37706083264260676, 1.0]]]}
ecp = {}
CPU time:        51.27
Set gradient conv threshold to 3.16228e-05
cond(S) = 7.912389027176285
E1 = -3.8531262828449533  E_coul = 1.0237248461020676
init E= -2.82940143674289
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.90589440161424  LUMO = 1.79796704762584
  mo_energy =
[-0.9058944   1.79796705 17.7163767 ]
E1 = -3.8643794715709534  E_coul = 1.0288189665327034
cycle= 1 E= -2.83556050503825  delta_E= -0.00616  |g|= 0.0101  |ddm|= 0.021
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.903372145785336  LUMO = 1.80244084640363
  mo_energy =
[-0.90337215  1.80244085 17.72028791]
E1 = -3.8642435249339346  E_coul = 1.0286801396862402
cycle= 2 E= -2.83556338524769  delta_E= -2.88e-06  |g|= 0.000477  |ddm|= 0.000881
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.903444848079322  LUMO = 1.80239353498459
  mo_energy =
[-0.90344485  1.80239353 17.71988822]
E1 = -3.8642483590497854  E_coul = 1.0286849671369378
cycle= 3 E= -2.83556339191285  delta_E= -6.67e-09  |g|= 5.19e-06  |ddm|= 6.41e-05
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.903438721087131  LUMO = 1.80239891142498
  mo_energy =
[-0.90343872  1.80239891 17.71991071]
E1 = -3.8642493405383007  E_coul = 1.028685948621897
cycle= 4 E= -2.8355633919164  delta_E= -3.56e-12  |g|= 6.3e-10  |ddm|= 3.09e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.8642493405383007  E_coul = 1.028685948621897
  HOMO = -0.903438721647253  LUMO = 1.80239891113426
  mo_energy =
[-0.90343872  1.80239891 17.71991071]
E1 = -3.8642493406685015  E_coul = 1.0286859487520972
Extra cycle  E= -2.8355633919164  delta_E= -4.44e-16  |g|= 4.18e-11  |ddm|= 3.52e-10
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 7.912389027176285
E1 = -3.8642493406685015  E_coul = 1.0286859487520972
init E= -2.8355633919164
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  HOMO = -0.903438721582154  LUMO = 1.80239891119043
  mo_energy =
[-0.90343872  1.80239891 17.71991071]
E1 = -3.8642493406779868  E_coul = 1.0286859487615825
cycle= 1 E= -2.8355633919164  delta_E=    0  |g|= 3.75e-12  |ddm|= 2.77e-11
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -3.8642493406779868  E_coul = 1.0286859487615825
  HOMO = -0.903438721577409  LUMO = 1.80239891119457
  mo_energy =
[-0.90343872  1.80239891 17.71991071]
E1 = -3.86424934067872  E_coul = 1.0286859487623157
Extra cycle  E= -2.8355633919164  delta_E=    0  |g|= 3.4e-13  |ddm|= 2.24e-12
    CPU time for scf_cycle      0.07 sec, wall time      0.08 sec
exp = [12.83504346  1.91733245  0.37706083]
grad_E = [-0.00010529 -0.00279294  0.01218761]
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:41 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  13.7654326006        1
[INPUT] 0    0    [1    /1   ]  2.01062376014        1
[INPUT] 0    0    [1    /1   ]  0.383755158261       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [13.765432600646331, 1.0]], [0, [2.010623760136057, 1.0]], [0, [0.3837551582614286, 1.0]]]}
ecp = {}
CPU time:        53.58
Set gradient conv threshold to 3.16228e-05
cond(S) = 7.581319699782774
E1 = -3.85308859457297  E_coul = 1.023761977580111
init E= -2.82932661699286
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.905939618138324  LUMO = 1.87479436885431
  mo_energy =
[-0.90593962  1.87479437 18.98675752]
E1 = -3.864461147294462  E_coul = 1.0287864774816602
cycle= 1 E= -2.8356746698128  delta_E= -0.00635  |g|= 0.00892  |ddm|= 0.017
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.903445159954915  LUMO = 1.87941189010588
  mo_energy =
[-0.90344516  1.87941189 18.99040461]
E1 = -3.8641993255937983  E_coul = 1.0285224402038107
cycle= 2 E= -2.83567688538999  delta_E= -2.22e-06  |g|= 0.000378  |ddm|= 0.000688
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.903582947686199  LUMO = 1.87929974838216
  mo_energy =
[-0.90358295  1.87929975 18.98975859]
E1 = -3.8641910458053568  E_coul = 1.0285141565748082
cycle= 3 E= -2.83567688923055  delta_E= -3.84e-09  |g|= 1.44e-06  |ddm|= 2.96e-05
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.90358123331096  LUMO = 1.87930131209239
  mo_energy =
[-0.90358123  1.87930131 18.98976506]
E1 = -3.86419131080485  E_coul = 1.028514421574038
cycle= 4 E= -2.83567688923081  delta_E= -2.63e-13  |g|= 4.74e-10  |ddm|= 8.24e-07
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.86419131080485  E_coul = 1.028514421574038
  HOMO = -0.903581233828387  LUMO = 1.87930131189174
  mo_energy =
[-0.90358123  1.87930131 18.98976506]
E1 = -3.8641913109006234  E_coul = 1.0285144216698103
Extra cycle  E= -2.83567688923081  delta_E= -8.88e-16  |g|= 3.07e-11  |ddm|= 2.59e-10
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
exp = [13.7654326   2.01062376  0.38375516]
E = -2.835676889230813
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:42 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  13.7654326006        1
[INPUT] 0    0    [1    /1   ]  2.01062376014        1
[INPUT] 0    0    [1    /1   ]  0.383755158261       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [13.765432600646331, 1.0]], [0, [2.010623760136057, 1.0]], [0, [0.3837551582614286, 1.0]]]}
ecp = {}
CPU time:        53.99
Set gradient conv threshold to 3.16228e-05
cond(S) = 7.581319699782774
E1 = -3.85308859457297  E_coul = 1.023761977580111
init E= -2.82932661699286
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.905939618138324  LUMO = 1.87479436885431
  mo_energy =
[-0.90593962  1.87479437 18.98675752]
E1 = -3.864461147294462  E_coul = 1.0287864774816602
cycle= 1 E= -2.8356746698128  delta_E= -0.00635  |g|= 0.00892  |ddm|= 0.017
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.903445159954915  LUMO = 1.87941189010588
  mo_energy =
[-0.90344516  1.87941189 18.99040461]
E1 = -3.8641993255937983  E_coul = 1.0285224402038107
cycle= 2 E= -2.83567688538999  delta_E= -2.22e-06  |g|= 0.000378  |ddm|= 0.000688
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.903582947686199  LUMO = 1.87929974838216
  mo_energy =
[-0.90358295  1.87929975 18.98975859]
E1 = -3.8641910458053568  E_coul = 1.0285141565748082
cycle= 3 E= -2.83567688923055  delta_E= -3.84e-09  |g|= 1.44e-06  |ddm|= 2.96e-05
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.90358123331096  LUMO = 1.87930131209239
  mo_energy =
[-0.90358123  1.87930131 18.98976506]
E1 = -3.86419131080485  E_coul = 1.028514421574038
cycle= 4 E= -2.83567688923081  delta_E= -2.63e-13  |g|= 4.74e-10  |ddm|= 8.24e-07
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.86419131080485  E_coul = 1.028514421574038
  HOMO = -0.903581233828387  LUMO = 1.87930131189174
  mo_energy =
[-0.90358123  1.87930131 18.98976506]
E1 = -3.8641913109006234  E_coul = 1.0285144216698103
Extra cycle  E= -2.83567688923081  delta_E= -8.88e-16  |g|= 3.07e-11  |ddm|= 2.59e-10
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 7.581319699782774
E1 = -3.8641913109006234  E_coul = 1.0285144216698103
init E= -2.83567688923081
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  HOMO = -0.903581233780501  LUMO = 1.87930131193484
  mo_energy =
[-0.90358123  1.87930131 18.98976506]
E1 = -3.8641913109074313  E_coul = 1.0285144216766198
cycle= 1 E= -2.83567688923081  delta_E= 1.33e-15  |g|= 2.64e-12  |ddm|= 1.97e-11
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -3.8641913109074313  E_coul = 1.0285144216766198
  HOMO = -0.903581233777095  LUMO = 1.87930131193793
  mo_energy =
[-0.90358123  1.87930131 18.98976506]
E1 = -3.8641913109079424  E_coul = 1.0285144216771307
Extra cycle  E= -2.83567688923081  delta_E= -4.44e-16  |g|= 2.27e-13  |ddm|= 1.54e-12
    CPU time for scf_cycle      0.08 sec, wall time      0.08 sec
exp = [13.7654326   2.01062376  0.38375516]
grad_E = [ 3.50825404e-05  1.79247757e-04 -1.41509533e-03]
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:44 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  13.6112080853        1
[INPUT] 0    0    [1    /1   ]  2.00080328681        1
[INPUT] 0    0    [1    /1   ]  0.382950356791       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [13.61120808534527, 1.0]], [0, [2.000803286805224, 1.0]], [0, [0.3829503567908399, 1.0]]]}
ecp = {}
CPU time:        56.24
Set gradient conv threshold to 3.16228e-05
cond(S) = 7.63275214759455
E1 = -3.8531710427577583  E_coul = 1.023768330658926
init E= -2.82940271209883
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.905937893938055  LUMO = 1.86658503661751
  mo_energy =
[-0.90593789  1.86658504 18.79487395]
E1 = -3.8643810908180254  E_coul = 1.0287039042771
cycle= 1 E= -2.83567718654093  delta_E= -0.00627  |g|= 0.00884  |ddm|= 0.017
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.903487694688001  LUMO = 1.8711355462211
  mo_energy =
[-0.90348769  1.87113555 18.79842906]
E1 = -3.864120680918091  E_coul = 1.0284412996609136
cycle= 2 E= -2.83567938125718  delta_E= -2.19e-06  |g|= 0.000377  |ddm|= 0.000688
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.90362476478563  LUMO = 1.87102465344234
  mo_energy =
[-0.90362476  1.87102465 18.79778962]
E1 = -3.8641125716968183  E_coul = 1.0284331865911467
cycle= 3 E= -2.83567938510567  delta_E= -3.85e-09  |g|= 1.52e-06  |ddm|= 3e-05
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.903622958709432  LUMO = 1.87102629454329
  mo_energy =
[-0.90362296  1.87102629 18.79779641]
E1 = -3.864112851756639  E_coul = 1.0284334666506731
cycle= 4 E= -2.83567938510597  delta_E= -2.94e-13  |g|= 4.76e-10  |ddm|= 8.72e-07
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.864112851756639  E_coul = 1.0284334666506731
  HOMO = -0.903622959227643  LUMO = 1.87102629434278
  mo_energy =
[-0.90362296  1.87102629 18.79779641]
E1 = -3.8641128518529677  E_coul = 1.0284334667470014
Extra cycle  E= -2.83567938510597  delta_E= -8.88e-16  |g|= 3.08e-11  |ddm|= 2.6e-10
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
exp = [13.61120809  2.00080329  0.38295036]
E = -2.8356793851059665
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:45 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  13.6112080853        1
[INPUT] 0    0    [1    /1   ]  2.00080328681        1
[INPUT] 0    0    [1    /1   ]  0.382950356791       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [13.61120808534527, 1.0]], [0, [2.000803286805224, 1.0]], [0, [0.3829503567908399, 1.0]]]}
ecp = {}
CPU time:        56.66
Set gradient conv threshold to 3.16228e-05
cond(S) = 7.63275214759455
E1 = -3.8531710427577583  E_coul = 1.023768330658926
init E= -2.82940271209883
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.905937893938055  LUMO = 1.86658503661751
  mo_energy =
[-0.90593789  1.86658504 18.79487395]
E1 = -3.8643810908180254  E_coul = 1.0287039042771
cycle= 1 E= -2.83567718654093  delta_E= -0.00627  |g|= 0.00884  |ddm|= 0.017
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.903487694688001  LUMO = 1.8711355462211
  mo_energy =
[-0.90348769  1.87113555 18.79842906]
E1 = -3.864120680918091  E_coul = 1.0284412996609136
cycle= 2 E= -2.83567938125718  delta_E= -2.19e-06  |g|= 0.000377  |ddm|= 0.000688
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.90362476478563  LUMO = 1.87102465344234
  mo_energy =
[-0.90362476  1.87102465 18.79778962]
E1 = -3.8641125716968183  E_coul = 1.0284331865911467
cycle= 3 E= -2.83567938510567  delta_E= -3.85e-09  |g|= 1.52e-06  |ddm|= 3e-05
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.903622958709432  LUMO = 1.87102629454329
  mo_energy =
[-0.90362296  1.87102629 18.79779641]
E1 = -3.864112851756639  E_coul = 1.0284334666506731
cycle= 4 E= -2.83567938510597  delta_E= -2.94e-13  |g|= 4.76e-10  |ddm|= 8.72e-07
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.864112851756639  E_coul = 1.0284334666506731
  HOMO = -0.903622959227643  LUMO = 1.87102629434278
  mo_energy =
[-0.90362296  1.87102629 18.79779641]
E1 = -3.8641128518529677  E_coul = 1.0284334667470014
Extra cycle  E= -2.83567938510597  delta_E= -8.88e-16  |g|= 3.08e-11  |ddm|= 2.6e-10
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 7.63275214759455
E1 = -3.8641128518529677  E_coul = 1.0284334667470014
init E= -2.83567938510597
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  HOMO = -0.903622959179481  LUMO = 1.87102629438594
  mo_energy =
[-0.90362296  1.87102629 18.79779641]
E1 = -3.864112851859826  E_coul = 1.0284334667538604
cycle= 1 E= -2.83567938510597  delta_E= 8.88e-16  |g|= 2.66e-12  |ddm|= 1.98e-11
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -3.864112851859826  E_coul = 1.0284334667538604
  HOMO = -0.903622959176053  LUMO = 1.87102629438904
  mo_energy =
[-0.90362296  1.87102629 18.79779641]
E1 = -3.86411285186034  E_coul = 1.0284334667543753
Extra cycle  E= -2.83567938510596  delta_E= 8.88e-16  |g|= 2.33e-13  |ddm|= 1.56e-12
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
exp = [13.61120809  2.00080329  0.38295036]
grad_E = [-2.46095054e-05  3.75336630e-04 -1.23305832e-03]
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:47 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  13.609937991         1
[INPUT] 0    0    [1    /1   ]  1.9949843516         1
[INPUT] 0    0    [1    /1   ]  0.382749524469       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [13.609937990993078, 1.0]], [0, [1.9949843515995964, 1.0]], [0, [0.3827495244685315, 1.0]]]}
ecp = {}
CPU time:        58.89
Set gradient conv threshold to 3.16228e-05
cond(S) = 7.63539221735187
E1 = -3.853111257343104  E_coul = 1.023762057417126
init E= -2.82934919992598
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.905939595272718  LUMO = 1.86223743459648
  mo_energy =
[-0.9059396   1.86223743 18.77385014]
E1 = -3.8645277198355505  E_coul = 1.0288506921068017
cycle= 1 E= -2.83567702772875  delta_E= -0.00633  |g|= 0.00916  |ddm|= 0.0178
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.903414281057054  LUMO = 1.8668580707399
  mo_energy =
[-0.90341428  1.86685807 18.77762843]
E1 = -3.864290288071785  E_coul = 1.0286109403431103
cycle= 2 E= -2.83567934772868  delta_E= -2.32e-06  |g|= 0.000396  |ddm|= 0.000697
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.903539464866664  LUMO = 1.86675867116815
  mo_energy =
[-0.90353946  1.86675867 18.7770305 ]
E1 = -3.864284424680684  E_coul = 1.0286050727609235
cycle= 3 E= -2.83567935191976  delta_E= -4.19e-09  |g|= 2.12e-06  |ddm|= 3.31e-05
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.903536942657027  LUMO = 1.8667609583084
  mo_energy =
[-0.90353694  1.86676096 18.77703999]
E1 = -3.8642848174864675  E_coul = 1.0286054655661316
cycle= 4 E= -2.83567935192034  delta_E= -5.75e-13  |g|= 5.02e-10  |ddm|= 1.22e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.8642848174864675  E_coul = 1.0286054655661316
  HOMO = -0.903536943177102  LUMO = 1.86676095808506
  mo_energy =
[-0.90353694  1.86676096 18.77703998]
E1 = -3.864284817588137  E_coul = 1.0286054656677996
Extra cycle  E= -2.83567935192034  delta_E= -1.33e-15  |g|= 3.26e-11  |ddm|= 2.75e-10
    CPU time for scf_cycle      0.06 sec, wall time      0.06 sec
exp = [13.60993799  1.99498435  0.38274952]
E = -2.835679351920337
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:47 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  13.6105839105        1
[INPUT] 0    0    [1    /1   ]  1.99794363088        1
[INPUT] 0    0    [1    /1   ]  0.382851659809       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [13.610583910525309, 1.0]], [0, [1.9979436308843315, 1.0]], [0, [0.3828516598094677, 1.0]]]}
ecp = {}
CPU time:        59.25
Set gradient conv threshold to 3.16228e-05
cond(S) = 7.634035002757487
E1 = -3.8531427061705097  E_coul = 1.0237653939969178
init E= -2.82937731217359
    CPU time for initialize scf      0.01 sec, wall time      0.01 sec
  HOMO = -0.90593891060981  LUMO = 1.86444819493987
  mo_energy =
[-0.90593891  1.86444819 18.78454324]
E1 = -3.864453826887287  E_coul = 1.0287762315835272
cycle= 1 E= -2.83567759530376  delta_E= -0.0063  |g|= 0.00899  |ddm|= 0.0174
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.903451764067382  LUMO = 1.86903320598494
  mo_energy =
[-0.90345176  1.86903321 18.78820822]
E1 = -3.864204692285058  E_coul = 1.0285248421589543
cycle= 2 E= -2.8356798501261  delta_E= -2.25e-06  |g|= 0.000386  |ddm|= 0.000691
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.903583001704791  LUMO = 1.86892796003289
  mo_energy =
[-0.903583    1.86892796 18.78758916]
E1 = -3.8641976832060037  E_coul = 1.0285178290710557
cycle= 3 E= -2.83567985413495  delta_E= -4.01e-09  |g|= 1.81e-06  |ddm|= 3.13e-05
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.90358084436481  LUMO = 1.86892991846303
  mo_energy =
[-0.90358084  1.86892992 18.78759727]
E1 = -3.864198018503142  E_coul = 1.0285181643677743
cycle= 4 E= -2.83567985413537  delta_E= -4.2e-13  |g|= 4.89e-10  |ddm|= 1.04e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.864198018503142  E_coul = 1.0285181643677743
  HOMO = -0.903580844883797  LUMO = 1.86892991825097
  mo_energy =
[-0.90358084  1.86892992 18.78759727]
E1 = -3.8641980186020857  E_coul = 1.0285181644667174
Extra cycle  E= -2.83567985413537  delta_E= -8.88e-16  |g|= 3.17e-11  |ddm|= 2.67e-10
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [13.61058391  1.99794363  0.38285166]
E = -2.8356798541353685
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:47 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  13.6105839105        1
[INPUT] 0    0    [1    /1   ]  1.99794363088        1
[INPUT] 0    0    [1    /1   ]  0.382851659809       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [13.610583910525309, 1.0]], [0, [1.9979436308843315, 1.0]], [0, [0.3828516598094677, 1.0]]]}
ecp = {}
CPU time:        59.62
Set gradient conv threshold to 3.16228e-05
cond(S) = 7.634035002757487
E1 = -3.8531427061705097  E_coul = 1.0237653939969178
init E= -2.82937731217359
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.90593891060981  LUMO = 1.86444819493987
  mo_energy =
[-0.90593891  1.86444819 18.78454324]
E1 = -3.864453826887287  E_coul = 1.0287762315835272
cycle= 1 E= -2.83567759530376  delta_E= -0.0063  |g|= 0.00899  |ddm|= 0.0174
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.903451764067382  LUMO = 1.86903320598494
  mo_energy =
[-0.90345176  1.86903321 18.78820822]
E1 = -3.864204692285058  E_coul = 1.0285248421589543
cycle= 2 E= -2.8356798501261  delta_E= -2.25e-06  |g|= 0.000386  |ddm|= 0.000691
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.903583001704791  LUMO = 1.86892796003289
  mo_energy =
[-0.903583    1.86892796 18.78758916]
E1 = -3.8641976832060037  E_coul = 1.0285178290710557
cycle= 3 E= -2.83567985413495  delta_E= -4.01e-09  |g|= 1.81e-06  |ddm|= 3.13e-05
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.90358084436481  LUMO = 1.86892991846303
  mo_energy =
[-0.90358084  1.86892992 18.78759727]
E1 = -3.864198018503142  E_coul = 1.0285181643677743
cycle= 4 E= -2.83567985413537  delta_E= -4.2e-13  |g|= 4.89e-10  |ddm|= 1.04e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.864198018503142  E_coul = 1.0285181643677743
  HOMO = -0.903580844883797  LUMO = 1.86892991825097
  mo_energy =
[-0.90358084  1.86892992 18.78759727]
E1 = -3.8641980186020857  E_coul = 1.0285181644667174
Extra cycle  E= -2.83567985413537  delta_E= -8.88e-16  |g|= 3.17e-11  |ddm|= 2.67e-10
    CPU time for scf_cycle      0.07 sec, wall time      0.07 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 7.634035002757487
E1 = -3.8641980186020857  E_coul = 1.0285181644667174
init E= -2.83567985413537
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  HOMO = -0.903580844834324  LUMO = 1.86892991829525
  mo_energy =
[-0.90358084  1.86892992 18.78759727]
E1 = -3.8641980186091396  E_coul = 1.0285181644737718
cycle= 1 E= -2.83567985413537  delta_E= 8.88e-16  |g|= 2.74e-12  |ddm|= 2.04e-11
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -3.8641980186091396  E_coul = 1.0285181644737718
  HOMO = -0.903580844830796  LUMO = 1.86892991829843
  mo_energy =
[-0.90358084  1.86892992 18.78759727]
E1 = -3.8641980186096734  E_coul = 1.0285181644743044
Extra cycle  E= -2.83567985413537  delta_E= -1.33e-15  |g|= 2.41e-13  |ddm|= 1.61e-12
    CPU time for scf_cycle      0.08 sec, wall time      0.08 sec
exp = [13.61058391  1.99794363  0.38285166]
grad_E = [-3.68873591e-06  1.48377065e-07  2.83861669e-05]
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:50 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  13.6237937672        1
[INPUT] 0    0    [1    /1   ]  1.9989708211         1
[INPUT] 0    0    [1    /1   ]  0.382938824053       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [13.623793767223205, 1.0]], [0, [1.9989708210974233, 1.0]], [0, [0.38293882405300855, 1.0]]]}
ecp = {}
CPU time:        62.23
Set gradient conv threshold to 3.16228e-05
cond(S) = 7.629728785345541
E1 = -3.8531366460116994  E_coul = 1.0237654478129148
init E= -2.82937119819878
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.905938908487471  LUMO = 1.86533007084544
  mo_energy =
[-0.90593891  1.86533007 18.8016383 ]
E1 = -3.864461653630844  E_coul = 1.028784036041228
cycle= 1 E= -2.83567761758962  delta_E= -0.00631  |g|= 0.009  |ddm|= 0.0174
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.903447872658991  LUMO = 1.86992126560855
  mo_energy =
[-0.90344787  1.86992127 18.80531222]
E1 = -3.8642120113188163  E_coul = 1.02853213963662
cycle= 2 E= -2.8356798716822  delta_E= -2.25e-06  |g|= 0.000386  |ddm|= 0.000691
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.9035793716708  LUMO = 1.86981571518923
  mo_energy =
[-0.90357937  1.86981572 18.80469191]
E1 = -3.8642049475271967  E_coul = 1.0285250718437517
cycle= 3 E= -2.83567987568344  delta_E= -4e-09  |g|= 1.8e-06  |ddm|= 3.12e-05
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.903577235454084  LUMO = 1.86981765523045
  mo_energy =
[-0.90357724  1.86981766 18.80469994]
E1 = -3.864205279421953  E_coul = 1.028525403738096
cycle= 4 E= -2.83567987568386  delta_E= -4.12e-13  |g|= 4.88e-10  |ddm|= 1.03e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.864205279421953  E_coul = 1.028525403738096
  HOMO = -0.903577235972881  LUMO = 1.86981765501881
  mo_energy =
[-0.90357724  1.86981766 18.80469994]
E1 = -3.864205279520734  E_coul = 1.0285254038368765
Extra cycle  E= -2.83567987568386  delta_E= -4.44e-16  |g|= 3.16e-11  |ddm|= 2.67e-10
    CPU time for scf_cycle      0.08 sec, wall time      0.08 sec
exp = [13.62379377  1.99897082  0.38293882]
E = -2.8356798756838573
#INFO: **** input file is /Users/deyanmihaylov/Documents/Work/pyscf_basis_opt/pyscfad_test.py ****
import pyscf
from pyscfad import gto, scf
import numpy as np

from scipy import optimize

# basis_string = '\n'.join([f'''
#     He  S
#         {x}              1.0'''
#         for x in exponent])

def He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponent}")
    print(f"E = {e}")

    return e

def grad_He_energy(exponent):
    mol = gto.Mole()
    mol.atom = 'He 0 0 0'  # in Angstrom

    basis_string = '\n'.join([f'''
    He  S
        {x}              1.0'''
        for x in exponent])
    mol.basis = {'He': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = 5
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponent}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def run_minimize(n):
    print(f"Searching in {n} dimensions")
    
    cons = (
        {'type': 'ineq', 'fun': lambda x: x[i] - x[i+1]}
        for i in range(n-1)
    )

    minimize_methods = [
        "Nelder-Mead",
        "Powell",
        "CG",
        "BFGS",
        "Newton-CG",
        "L-BFGS-B",
        "TNC",
        "COBYLA",
        "SLSQP",
        "trust-constr",
        "dogleg",
        "trust-ncg",
        "trust-exact",
        "trust-krylov",
    ]

    for method in minimize_methods:
        print(f"Using method {method}")

        if method not in ["Powell", "COBYLA"]:
            jac = grad_He_energy
        else:
            jac = None

        if method not in ["CG", "BFGS", "Newton-CG", "COBYLA"]:
            bnds = ((1e-6, None) for _ in range(n))
        else:
            bnds = None

        counter = 0
        while True:
            try:
                x0 = np.random.uniform(low=1e-6, high=10.0, size=n)

                res = optimize.minimize(
                    He_energy,
                    x0,
                    args=(),
                    method=method,
                    jac=jac,
                    hess=None,
                    hessp=None,
                    bounds=bnds,
                    # constraints=cons,
                    tol=1e-8,
                    callback=None,
                    # options={"xtol": 1e-8, "ftol": 1e-8},
                )
                print(res)
                break
            except:
                print(f"Method {method} failed with x0 = {x0} for n = {n}")
                counter += 1

                if counter > 10: break


def minimize_energy(n):
    x0 = [0.5 * (n-i) for i in range(n)]
    bnds = ((1e-6, None) for _ in range(n))

    res = optimize.minimize(
        He_energy,
        x0,
        args=(),
        method="SLSQP",
        jac=grad_He_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-8,
        callback=None,
        # options={"xtol": 1e-8, "ftol": 1e-8},
    )
    print(res)

minimize_energy(3)





# res = optimize.root(
#     grad_He_energy,
#     [1, 1e-4],
#     args=(),
#     method='hybr',
#     jac=None,
#     tol=None,
#     callback=None,
#     options=None,
# )

# print(res)
# print(He_energy(res.x))



# print(grad_He_energy([1.880e+00, 3.031e-01]))

# resbrute = optimize.direct(
#     He_energy,
#     ((1e-4,20), (1e-4,20)),
#     maxfun=100000,
#     maxiter=100000,
#     locally_biased=False,
# )

# print(resbrute)



# x0 = [0.1432879285E+01]
# res = optimize.minimize(
#     He_energy,
#     x0,
#     jac=grad_He_energy,
#     bounds=(Bounds(lb=1e-4)),
#     method='SLSQP', tol=1e-8,
# )

# minimizer_kwargs = {"method": "SLSQP", "jac": grad_He_energy, "bounds": ((1e-4, None), (1e-4, None)),}
# res = basinhopping(
#     He_energy,
#     x0,
#     niter=100,
#     minimizer_kwargs=minimizer_kwargs,
#     T=1,
#     )

# print(res.x)
# print(He_energy(res.x))
# print(res.values())

# print("E", He_energy(71.6168370))

# print(f'Nuclaer gradient:\n{jac.coords}')
# print(f'Gradient wrt basis exponents:\n{jac.exp}')
# print(f'Gradient wrt basis contraction coefficients:\n{jac.ctr_coeff}')#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Deyans-MacBook-Pro-Home.local', release='22.1.0', version='Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:54 PDT 2022; root:xnu-8792.41.9~2/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.16 (default, Mar  1 2023, 21:19:10) 
[Clang 14.0.6 ]
numpy 1.24.2  scipy 1.10.1
Date: Mon Mar  6 15:02:51 2023
PySCF version 2.1.1
PySCF path  /Users/deyanmihaylov/opt/anaconda3/envs/pyscfad_env/lib/python3.8/site-packages/pyscf

[CONFIG] conf_file /Users/deyanmihaylov/.pyscf_conf.py
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 2
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 He     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] He
[INPUT] 0    0    [1    /1   ]  13.6237937672        1
[INPUT] 0    0    [1    /1   ]  1.9989708211         1
[INPUT] 0    0    [1    /1   ]  0.382938824053       1

nuclear repulsion = 0
number of shells = 3
number of NR pGTOs = 3
number of NR cGTOs = 3
basis = {'He': [[0, [13.623793767223205, 1.0]], [0, [1.9989708210974233, 1.0]], [0, [0.38293882405300855, 1.0]]]}
ecp = {}
CPU time:        62.68
Set gradient conv threshold to 3.16228e-05
cond(S) = 7.629728785345541
E1 = -3.8531366460116994  E_coul = 1.0237654478129148
init E= -2.82937119819878
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  HOMO = -0.905938908487471  LUMO = 1.86533007084544
  mo_energy =
[-0.90593891  1.86533007 18.8016383 ]
E1 = -3.864461653630844  E_coul = 1.028784036041228
cycle= 1 E= -2.83567761758962  delta_E= -0.00631  |g|= 0.009  |ddm|= 0.0174
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
  HOMO = -0.903447872658991  LUMO = 1.86992126560855
  mo_energy =
[-0.90344787  1.86992127 18.80531222]
E1 = -3.8642120113188163  E_coul = 1.02853213963662
cycle= 2 E= -2.8356798716822  delta_E= -2.25e-06  |g|= 0.000386  |ddm|= 0.000691
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
  HOMO = -0.9035793716708  LUMO = 1.86981571518923
  mo_energy =
[-0.90357937  1.86981572 18.80469191]
E1 = -3.8642049475271967  E_coul = 1.0285250718437517
cycle= 3 E= -2.83567987568344  delta_E= -4e-09  |g|= 1.8e-06  |ddm|= 3.12e-05
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
  HOMO = -0.903577235454084  LUMO = 1.86981765523045
  mo_energy =
[-0.90357724  1.86981766 18.80469994]
E1 = -3.864205279421953  E_coul = 1.028525403738096
cycle= 4 E= -2.83567987568386  delta_E= -4.12e-13  |g|= 4.88e-10  |ddm|= 1.03e-06
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -3.864205279421953  E_coul = 1.028525403738096
  HOMO = -0.903577235972881  LUMO = 1.86981765501881
  mo_energy =
[-0.90357724  1.86981766 18.80469994]
E1 = -3.864205279520734  E_coul = 1.0285254038368765
Extra cycle  E= -2.83567987568386  delta_E= -4.44e-16  |g|= 3.16e-11  |ddm|= 2.67e-10
    CPU time for scf_cycle      0.06 sec, wall time      0.06 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 7.629728785345541
E1 = -3.864205279520734  E_coul = 1.0285254038368765
init E= -2.83567987568386
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  HOMO = -0.903577235923491  LUMO = 1.86981765506303
  mo_energy =
[-0.90357724  1.86981766 18.80469994]
E1 = -3.8642052795277784  E_coul = 1.0285254038439207
cycle= 1 E= -2.83567987568386  delta_E= -4.44e-16  |g|= 2.73e-12  |ddm|= 2.04e-11
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -3.8642052795277784  E_coul = 1.0285254038439207
  HOMO = -0.903577235919968  LUMO = 1.86981765506621
  mo_energy =
[-0.90357724  1.86981766 18.80469994]
E1 = -3.864205279528307  E_coul = 1.0285254038444496
Extra cycle  E= -2.83567987568386  delta_E= 4.44e-16  |g|= 2.41e-13  |ddm|= 1.6e-12
    CPU time for scf_cycle      0.07 sec, wall time      0.08 sec
exp = [13.62379377  1.99897082  0.38293882]
grad_E = [ 2.99495816e-07  8.31456460e-07 -2.10889161e-05]
 message: Optimization terminated successfully
 success: True
  status: 0
     fun: -2.8356798756838573
       x: [ 1.362e+01  1.999e+00  3.829e-01]
     nit: 24
     jac: [ 2.995e-07  8.315e-07 -2.109e-05]
    nfev: 27
    njev: 24
